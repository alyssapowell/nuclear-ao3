package main

import (
	"database/sql"
	"fmt"
	"log"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/lib/pq"
	"nuclear-ao3/shared/models"
)

// Work CRUD operations

func (ws *WorkService) CreateWork(c *gin.Context) {
	var req models.CreateWorkRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request data", "details": err.Error()})
		return
	}

	// Get user ID from JWT token (would be set by auth middleware)
	userID, exists := c.Get("user_id")
	log.Printf("DEBUG: user_id from context: %v, exists: %v", userID, exists)
	if !exists {
		// For development, use a default user ID if not set by middleware
		userID = "672471fe-daa0-422d-8eea-4f9e4d1f285c" // testuser ID
		log.Printf("Warning: Using default user ID for development: %v", userID)
	}
	log.Printf("DEBUG: Final user_id to use: %v", userID)

	tx, err := ws.db.Begin()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to start transaction"})
		return
	}
	defer tx.Rollback()

	// Create work
	workID := uuid.New()
	now := time.Now()

	userUUID, err := uuid.Parse(userID.(string))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
		return
	}

	// Set defaults for required fields if not provided
	language := req.Language
	if language == "" {
		language = "en"
	}

	rating := req.Rating
	if rating == "" {
		rating = "Not Rated"
	}

	work := &models.Work{
		ID:                     workID,
		Title:                  req.Title,
		Summary:                req.Summary,
		Notes:                  req.Notes,
		UserID:                 userUUID,
		SeriesID:               req.SeriesID,
		Language:               language,
		Rating:                 rating,
		Category:               req.Category,
		Warnings:               req.Warnings,
		Fandoms:                req.Fandoms,
		Characters:             req.Characters,
		Relationships:          req.Relationships,
		FreeformTags:           req.FreeformTags,
		MaxChapters:            req.MaxChapters,
		ChapterCount:           1,
		IsComplete:             req.MaxChapters != nil && *req.MaxChapters == 1,
		Status:                 "draft",
		RestrictedToUsers:      false,  // Default to public
		CommentPolicy:          "open", // Default to open comments
		ModerateComments:       false,
		DisableComments:        false,
		IsAnonymous:            false, // Default to non-anonymous
		InAnonCollection:       false,
		InUnrevealedCollection: false,
		CreatedAt:              now,
		UpdatedAt:              now,
	}

	// Insert work with user_id
	query := `
		INSERT INTO works (id, title, summary, notes, user_id, series_id, language, rating, 
			category, warnings, fandoms, characters, relationships, freeform_tags, 
			expected_chapters, chapter_count, is_complete, status, 
			restricted_to_users, comment_policy, moderate_comments, disable_comments,
			is_anonymous, in_anon_collection, in_unrevealed_collection,
			created_at, updated_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27)`

	log.Printf("DEBUG: About to insert work with ChapterCount=%d, MaxChapters=%v", work.ChapterCount, work.MaxChapters)
	_, err = tx.Exec(query,
		work.ID, work.Title, work.Summary, work.Notes, work.UserID, work.SeriesID,
		work.Language, work.Rating, pq.Array(work.Category), pq.Array(work.Warnings),
		pq.Array(work.Fandoms), pq.Array(work.Characters), pq.Array(work.Relationships),
		pq.Array(work.FreeformTags), work.MaxChapters, work.ChapterCount,
		work.IsComplete, work.Status, work.RestrictedToUsers, work.CommentPolicy,
		work.ModerateComments, work.DisableComments, work.IsAnonymous,
		work.InAnonCollection, work.InUnrevealedCollection, work.CreatedAt, work.UpdatedAt)
	log.Printf("DEBUG: Work insert result - error: %v", err)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create work", "details": err.Error()})
		return
	}

	// Get user's default pseud or create one if none exists
	var defaultPseudID uuid.UUID
	err = tx.QueryRow(`
		SELECT id FROM pseuds 
		WHERE user_id = $1 AND is_default = true 
		LIMIT 1`, userID).Scan(&defaultPseudID)

	if err != nil {
		// If no default pseud exists, get the username and create one
		var username string
		err = tx.QueryRow("SELECT username FROM users WHERE id = $1", userID).Scan(&username)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get user info"})
			return
		}

		// Create default pseud
		defaultPseudID = uuid.New()
		_, err = tx.Exec(`
			INSERT INTO pseuds (id, user_id, name, is_default, created_at, updated_at)
			VALUES ($1, $2, $3, true, $4, $5)`,
			defaultPseudID, userID, username, now, now)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create default pseud"})
			return
		}
	}

	// Create creatorship for the work
	creatorshipID := uuid.New()
	_, err = tx.Exec(`
		INSERT INTO creatorships (id, creation_id, creation_type, pseud_id, approved, created_at, updated_at)
		VALUES ($1, $2, 'Work', $3, true, $4, $5)`,
		creatorshipID, workID, defaultPseudID, now, now)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create creatorship", "details": err.Error()})
		return
	}

	// Create first chapter
	chapterID := uuid.New()
	wordCount := countWords(req.ChapterContent)

	chapter := &models.Chapter{
		ID:        chapterID,
		WorkID:    workID,
		Number:    1,
		Title:     req.ChapterTitle,
		Summary:   req.ChapterSummary,
		Notes:     req.ChapterNotes,
		EndNotes:  req.ChapterEndNotes,
		Content:   req.ChapterContent,
		WordCount: wordCount,
		Status:    "draft",
		CreatedAt: now,
		UpdatedAt: now,
	}

	chapterQuery := `
		INSERT INTO chapters (id, work_id, chapter_number, title, summary, notes, end_notes, 
			content, word_count, is_draft, created_at, updated_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)`

	_, err = tx.Exec(chapterQuery,
		chapter.ID, chapter.WorkID, chapter.Number, chapter.Title, chapter.Summary,
		chapter.Notes, chapter.EndNotes, chapter.Content, chapter.WordCount,
		chapter.Status == "draft", chapter.CreatedAt, chapter.UpdatedAt)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create chapter", "details": err.Error()})
		return
	}

	// Update work word count
	_, err = tx.Exec("UPDATE works SET word_count = $1 WHERE id = $2", wordCount, workID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update word count"})
		return
	}

	// Work statistics are automatically initialized by the sync_work_statistics trigger

	if err = tx.Commit(); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to commit transaction"})
		return
	}

	work.WordCount = wordCount
	c.JSON(http.StatusCreated, gin.H{"work": work, "first_chapter": chapter})
}

func (ws *WorkService) GetWork(c *gin.Context) {
	workIDParam := c.Param("work_id")
	var workID uuid.UUID
	var err error

	// Try to parse as UUID first (modern format)
	workID, err = uuid.Parse(workIDParam)
	if err != nil {
		// If UUID parsing fails, try parsing as integer (legacy ID)
		if legacyID, parseErr := strconv.Atoi(workIDParam); parseErr == nil {
			// Look up work by legacy_id and redirect to UUID route
			var workUUID uuid.UUID
			err = ws.db.QueryRow("SELECT id FROM works WHERE legacy_id = $1", legacyID).Scan(&workUUID)
			if err != nil {
				if err == sql.ErrNoRows {
					c.JSON(http.StatusNotFound, gin.H{"error": "Work not found"})
				} else {
					c.JSON(http.StatusInternalServerError, gin.H{"error": "Database error"})
				}
				return
			}

			// 301 permanent redirect to UUID-based URL
			newURL := fmt.Sprintf("/api/v1/work/%s", workUUID.String())
			c.Redirect(http.StatusMovedPermanently, newURL)
			return
		}

		// Neither UUID nor integer - invalid format
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid work ID format"})
		return
	}

	// Query work details with all fields
	var work models.Work
	var legacyID sql.NullInt64
	var categoryStr, warningsStr sql.NullString
	var fandoms, characters, relationships, freeformTags pq.StringArray
	var summary sql.NullString
	var publishedAt sql.NullTime
	var status sql.NullString
	var maxChapters sql.NullInt64

	// Get user ID for privacy checks
	userID, hasUser := c.Get("user_id")
	var userUUID *uuid.UUID
	if hasUser {
		userIDStr := userID.(string)
		if userVal, err := uuid.Parse(userIDStr); err == nil {
			userUUID = &userVal
		}
	}

	// Check if user can view this work
	var canView bool
	err = ws.db.QueryRow("SELECT can_user_view_work($1, $2)", workID, userUUID).Scan(&canView)
	if err != nil || !canView {
		c.JSON(http.StatusForbidden, gin.H{"error": "Cannot view this work"})
		return
	}

	// Query work details with privacy controls
	query := `
		SELECT w.id, w.legacy_id, w.title, w.summary, w.language, w.rating,
			w.category, w.warnings, w.fandoms, w.characters, w.relationships, w.freeform_tags,
			w.word_count, w.chapter_count, w.max_chapters, w.is_complete, w.status,
			w.restricted_to_users, w.restricted_to_adults, w.comment_policy, w.moderate_comments, w.disable_comments,
			w.is_anonymous, w.in_anon_collection, w.in_unrevealed_collection,
			w.published_at, w.updated_at, w.created_at,
			COALESCE(w.hit_count, 0) as hits, COALESCE(w.kudos_count, 0) as kudos,
			COALESCE(w.comment_count, 0) as comments, COALESCE(w.bookmark_count, 0) as bookmarks
		FROM works w
		WHERE w.id = $1`

	// If no user, only allow non-draft, non-restricted works
	if !hasUser {
		query += " AND w.restricted_to_users = false"
	}

	// Execute query
	err = ws.db.QueryRow(query, workID).Scan(
		&work.ID, &legacyID, &work.Title, &summary,
		&work.Language, &work.Rating, &categoryStr, &warningsStr,
		&fandoms, &characters, &relationships, &freeformTags,
		&work.WordCount, &work.ChapterCount, &maxChapters,
		&work.IsComplete, &status, &work.RestrictedToUsers, &work.RestrictedToAdults,
		&work.CommentPolicy, &work.ModerateComments, &work.DisableComments,
		&work.IsAnonymous, &work.InAnonCollection, &work.InUnrevealedCollection,
		&publishedAt, &work.UpdatedAt, &work.CreatedAt,
		&work.Hits, &work.Kudos, &work.Comments, &work.Bookmarks,
	)

	if err == sql.ErrNoRows {
		c.JSON(http.StatusNotFound, gin.H{"error": "Work not found"})
		return
	}
	if err != nil {
		fmt.Printf("Database error in GetWork: %v\n", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch work", "details": err.Error()})
		return
	}

	// Handle nullable fields exactly like SearchWorks
	if summary.Valid {
		work.Summary = summary.String
	}
	if publishedAt.Valid {
		work.PublishedAt = &publishedAt.Time
	}
	if maxChapters.Valid {
		maxChapInt := int(maxChapters.Int64)
		work.MaxChapters = &maxChapInt
	}
	if status.Valid {
		work.Status = status.String
	}
	if legacyID.Valid {
		legacyInt := int(legacyID.Int64)
		work.LegacyID = &legacyInt
	}

	// Convert string fields to arrays exactly like SearchWorks
	if categoryStr.Valid && categoryStr.String != "" {
		work.Category = []string{categoryStr.String}
	}
	if warningsStr.Valid && warningsStr.String != "" {
		work.Warnings = []string{warningsStr.String}
	}
	work.Fandoms = []string(fandoms)
	work.Characters = []string(characters)
	work.Relationships = []string(relationships)
	work.FreeformTags = []string(freeformTags)

	// Get work authors using the new co-authorship system
	authorsRows, err := ws.db.Query("SELECT * FROM get_work_authors($1, $2)", workID, userID)
	if err != nil {
		fmt.Printf("Failed to get work authors: %v\n", err)
	} else {
		defer authorsRows.Close()
		authors := []models.WorkAuthor{}
		for authorsRows.Next() {
			var author models.WorkAuthor
			err := authorsRows.Scan(&author.PseudID, &author.PseudName, &author.UserID, &author.Username, &author.IsAnonymous)
			if err != nil {
				fmt.Printf("Failed to scan author: %v\n", err)
				continue
			}
			authors = append(authors, author)
		}

		// Return work with authors
		c.JSON(http.StatusOK, gin.H{
			"work":    work,
			"authors": authors,
		})
		return
	}

	// Fallback to old response format if authors query fails
	c.JSON(http.StatusOK, work)

}

func (ws *WorkService) UpdateWork(c *gin.Context) {
	workID, err := uuid.Parse(c.Param("work_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid work ID"})
		return
	}

	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	var req models.UpdateWorkRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request data", "details": err.Error()})
		return
	}

	// Verify ownership using creatorship system
	var isAuthor bool
	err = ws.db.QueryRow(`
		SELECT EXISTS(
			SELECT 1 FROM creatorships c
			JOIN pseuds p ON c.pseud_id = p.id
			WHERE c.creation_id = $1 AND c.creation_type = 'Work' 
			AND c.approved = true AND p.user_id = $2
		)`, workID, userID).Scan(&isAuthor)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to verify ownership"})
		return
	}

	if !isAuthor {
		c.JSON(http.StatusForbidden, gin.H{"error": "Not authorized to modify this work"})
		return
	}

	// Build dynamic update query
	updates := []string{}
	args := []interface{}{}
	argIndex := 1

	if req.Title != nil {
		updates = append(updates, fmt.Sprintf("title = $%d", argIndex))
		args = append(args, *req.Title)
		argIndex++
	}
	if req.Summary != nil {
		updates = append(updates, fmt.Sprintf("summary = $%d", argIndex))
		args = append(args, *req.Summary)
		argIndex++
	}
	if req.Notes != nil {
		updates = append(updates, fmt.Sprintf("notes = $%d", argIndex))
		args = append(args, *req.Notes)
		argIndex++
	}
	if req.Rating != nil {
		updates = append(updates, fmt.Sprintf("rating = $%d", argIndex))
		args = append(args, *req.Rating)
		argIndex++
	}
	if req.Category != nil {
		updates = append(updates, fmt.Sprintf("category = $%d", argIndex))
		args = append(args, pq.Array(req.Category))
		argIndex++
	}
	if req.Warnings != nil {
		updates = append(updates, fmt.Sprintf("warnings = $%d", argIndex))
		args = append(args, pq.Array(req.Warnings))
		argIndex++
	}
	if req.Fandoms != nil {
		updates = append(updates, fmt.Sprintf("fandoms = $%d", argIndex))
		args = append(args, pq.Array(req.Fandoms))
		argIndex++
	}
	if req.Characters != nil {
		updates = append(updates, fmt.Sprintf("characters = $%d", argIndex))
		args = append(args, pq.Array(req.Characters))
		argIndex++
	}
	if req.Relationships != nil {
		updates = append(updates, fmt.Sprintf("relationships = $%d", argIndex))
		args = append(args, pq.Array(req.Relationships))
		argIndex++
	}
	if req.FreeformTags != nil {
		updates = append(updates, fmt.Sprintf("freeform_tags = $%d", argIndex))
		args = append(args, pq.Array(req.FreeformTags))
		argIndex++
	}
	if req.MaxChapters != nil {
		updates = append(updates, fmt.Sprintf("max_chapters = $%d", argIndex))
		args = append(args, req.MaxChapters)
		argIndex++
	}
	if req.IsComplete != nil {
		updates = append(updates, fmt.Sprintf("is_complete = $%d", argIndex))
		args = append(args, *req.IsComplete)
		argIndex++
	}
	if req.Status != nil {
		updates = append(updates, fmt.Sprintf("status = $%d", argIndex))
		args = append(args, *req.Status)

		// If publishing for first time, set published_at
		if *req.Status == "posted" {
			argIndex++
			updates = append(updates, fmt.Sprintf("published_at = $%d", argIndex))
			args = append(args, time.Now())
		}
		argIndex++
	}
	if req.RestrictedToUsers != nil {
		updates = append(updates, fmt.Sprintf("restricted_to_users = $%d", argIndex))
		args = append(args, *req.RestrictedToUsers)
		argIndex++
	}
	if req.RestrictedToAdults != nil {
		updates = append(updates, fmt.Sprintf("restricted_to_adults = $%d", argIndex))
		args = append(args, *req.RestrictedToAdults)
		argIndex++
	}
	if req.CommentPolicy != nil {
		updates = append(updates, fmt.Sprintf("comment_policy = $%d", argIndex))
		args = append(args, *req.CommentPolicy)
		argIndex++
	}
	if req.ModerateComments != nil {
		updates = append(updates, fmt.Sprintf("moderate_comments = $%d", argIndex))
		args = append(args, *req.ModerateComments)
		argIndex++
	}
	if req.DisableComments != nil {
		updates = append(updates, fmt.Sprintf("disable_comments = $%d", argIndex))
		args = append(args, *req.DisableComments)
		argIndex++
	}
	if req.IsAnonymous != nil {
		updates = append(updates, fmt.Sprintf("is_anonymous = $%d", argIndex))
		args = append(args, *req.IsAnonymous)
		argIndex++
	}
	if req.InAnonCollection != nil {
		updates = append(updates, fmt.Sprintf("in_anon_collection = $%d", argIndex))
		args = append(args, *req.InAnonCollection)
		argIndex++
	}
	if req.InUnrevealedCollection != nil {
		updates = append(updates, fmt.Sprintf("in_unrevealed_collection = $%d", argIndex))
		args = append(args, *req.InUnrevealedCollection)
		argIndex++
	}

	if len(updates) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "No updates provided"})
		return
	}

	// Add updated_at
	updates = append(updates, fmt.Sprintf("updated_at = $%d", argIndex))
	args = append(args, time.Now())
	argIndex++

	// Add work ID for WHERE clause
	args = append(args, workID)

	query := fmt.Sprintf("UPDATE works SET %s WHERE id = $%d", strings.Join(updates, ", "), argIndex)

	_, err = ws.db.Exec(query, args...)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update work", "details": err.Error()})
		return
	}

	// Clear cache
	cacheKey := fmt.Sprintf("work:%s", workID)
	ws.redis.Del(c.Request.Context(), cacheKey)

	// Fetch updated work
	work, err := ws.getWorkByID(workID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch updated work"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"work": work})
}

func (ws *WorkService) DeleteWork(c *gin.Context) {
	workID, err := uuid.Parse(c.Param("work_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid work ID"})
		return
	}

	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	// Verify ownership using creatorship system
	var isAuthor bool
	err = ws.db.QueryRow(`
		SELECT EXISTS(
			SELECT 1 FROM creatorships c
			JOIN pseuds p ON c.pseud_id = p.id
			WHERE c.creation_id = $1 AND c.creation_type = 'Work' 
			AND c.approved = true AND p.user_id = $2
		)`, workID, userID).Scan(&isAuthor)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to verify ownership"})
		return
	}

	if !isAuthor {
		c.JSON(http.StatusForbidden, gin.H{"error": "Not authorized to delete this work"})
		return
	}

	tx, err := ws.db.Begin()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to start transaction"})
		return
	}
	defer tx.Rollback()

	// Delete related data (cascading)
	tables := []string{"gifts", "creatorships", "work_comments", "work_kudos", "bookmarks", "work_statistics", "chapters", "works"}
	for _, table := range tables {
		var query string
		if table == "works" {
			query = fmt.Sprintf("DELETE FROM %s WHERE id = $1", table)
		} else if table == "creatorships" || table == "gifts" {
			if table == "creatorships" {
				query = fmt.Sprintf("DELETE FROM %s WHERE creation_id = $1 AND creation_type = 'Work'", table)
			} else {
				query = fmt.Sprintf("DELETE FROM %s WHERE work_id = $1", table)
			}
		} else {
			query = fmt.Sprintf("DELETE FROM %s WHERE work_id = $1", table)
		}

		_, err = tx.Exec(query, workID)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete work data"})
			return
		}
	}

	if err = tx.Commit(); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to commit transaction"})
		return
	}

	// Clear cache
	cacheKey := fmt.Sprintf("work:%s", workID)
	ws.redis.Del(c.Request.Context(), cacheKey)

	c.JSON(http.StatusOK, gin.H{"message": "Work deleted successfully"})
}

func (ws *WorkService) SearchWorks(c *gin.Context) {
	// Parse query parameters
	query := c.DefaultQuery("q", "")
	fandoms := c.QueryArray("fandom")
	characters := c.QueryArray("character")
	relationships := c.QueryArray("relationship")
	tags := c.QueryArray("tag")
	rating := c.QueryArray("rating")
	category := c.QueryArray("category")
	warnings := c.QueryArray("warning")

	sortBy := c.DefaultQuery("sort", "updated_at")
	sortOrder := c.DefaultQuery("order", "desc")

	page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
	limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))
	if limit > 100 {
		limit = 100
	}
	offset := (page - 1) * limit

	// Get user ID for privacy filtering
	_, hasUser := c.Get("user_id")

	// Build SQL query - only show published works, not drafts
	baseQuery := `
		SELECT w.id, w.title, w.summary, w.user_id, u.username, w.language, w.rating,
			w.category, w.warnings, w.fandoms, w.characters, w.relationships, w.freeform_tags,
			w.word_count, w.chapter_count, w.max_chapters, w.is_complete, w.status,
			w.published_at, w.updated_at, w.created_at,
			COALESCE(w.hit_count, 0) as hits, COALESCE(w.kudos_count, 0) as kudos,
			COALESCE(w.comment_count, 0) as comments, COALESCE(w.bookmark_count, 0) as bookmarks
		FROM works w
		JOIN users u ON w.user_id = u.id
		WHERE w.status != 'draft' AND w.published_at IS NOT NULL`

	args := []interface{}{}
	argIndex := 1

	// If no user is logged in, exclude user-restricted works
	if !hasUser {
		baseQuery += " AND w.restricted_to_users = false"
	}

	conditions := []string{}

	if query != "" {
		conditions = append(conditions, fmt.Sprintf("(w.title ILIKE $%d OR w.summary ILIKE $%d)", argIndex, argIndex))
		args = append(args, "%"+query+"%")
		argIndex++
	}

	if len(fandoms) > 0 {
		conditions = append(conditions, fmt.Sprintf("w.fandoms && $%d", argIndex))
		args = append(args, pq.Array(fandoms))
		argIndex++
	}

	if len(characters) > 0 {
		conditions = append(conditions, fmt.Sprintf("w.characters && $%d", argIndex))
		args = append(args, pq.Array(characters))
		argIndex++
	}

	if len(relationships) > 0 {
		conditions = append(conditions, fmt.Sprintf("w.relationships && $%d", argIndex))
		args = append(args, pq.Array(relationships))
		argIndex++
	}

	if len(tags) > 0 {
		conditions = append(conditions, fmt.Sprintf("w.freeform_tags && $%d", argIndex))
		args = append(args, pq.Array(tags))
		argIndex++
	}

	if len(rating) > 0 {
		placeholders := []string{}
		for _, r := range rating {
			placeholders = append(placeholders, fmt.Sprintf("$%d", argIndex))
			args = append(args, r)
			argIndex++
		}
		conditions = append(conditions, fmt.Sprintf("w.rating IN (%s)", strings.Join(placeholders, ",")))
	}

	if len(category) > 0 {
		placeholders := []string{}
		for _, c := range category {
			placeholders = append(placeholders, fmt.Sprintf("$%d", argIndex))
			args = append(args, c)
			argIndex++
		}
		conditions = append(conditions, fmt.Sprintf("w.category IN (%s)", strings.Join(placeholders, ",")))
	}

	if len(warnings) > 0 {
		placeholders := []string{}
		for _, w := range warnings {
			placeholders = append(placeholders, fmt.Sprintf("$%d", argIndex))
			args = append(args, w)
			argIndex++
		}
		conditions = append(conditions, fmt.Sprintf("w.warnings IN (%s)", strings.Join(placeholders, ",")))
	}

	if len(conditions) > 0 {
		baseQuery += " AND " + strings.Join(conditions, " AND ")
	}

	// Add ordering
	allowedSort := map[string]bool{
		"title": true, "updated_at": true, "created_at": true, "published_at": true,
		"word_count": true, "hits": true, "kudos": true, "comments": true, "bookmarks": true,
	}
	if !allowedSort[sortBy] {
		sortBy = "updated_at"
	}
	if sortOrder != "asc" && sortOrder != "desc" {
		sortOrder = "desc"
	}

	baseQuery += fmt.Sprintf(" ORDER BY %s %s LIMIT $%d OFFSET $%d", sortBy, sortOrder, argIndex, argIndex+1)
	args = append(args, limit, offset)

	fmt.Printf("FINAL QUERY: %s\n", baseQuery)
	fmt.Printf("ARGS: %v\n", args)

	// Test simple query first
	var testCount int
	testErr := ws.db.QueryRow("SELECT COUNT(*) FROM works").Scan(&testCount)
	fmt.Printf("TEST QUERY: SELECT COUNT(*) FROM works = %d, err=%v\n", testCount, testErr)

	fmt.Printf("About to execute main query...\n")
	rows, err := ws.db.Query(baseQuery, args...)
	fmt.Printf("Query result: rows=%v, err=%v\n", rows != nil, err)
	if err != nil {
		fmt.Printf("Query failed: %v\n", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to search works", "details": err.Error()})
		return
	}
	defer rows.Close()
	fmt.Printf("Query executed successfully\n")

	works := []models.Work{}
	fmt.Printf("Starting to scan rows\n")
	for rows.Next() {
		fmt.Printf("Processing row\n")
		var work models.Work
		var categoryStr sql.NullString
		var warningsStr sql.NullString
		var fandoms, characters, relationships, freeformTags pq.StringArray

		err := rows.Scan(
			&work.ID, &work.Title, &work.Summary, &work.UserID, &work.Username,
			&work.Language, &work.Rating, &categoryStr, &warningsStr,
			&fandoms, &characters, &relationships, &freeformTags,
			&work.WordCount, &work.ChapterCount, &work.MaxChapters,
			&work.IsComplete, &work.Status, &work.PublishedAt, &work.UpdatedAt, &work.CreatedAt,
			&work.Hits, &work.Kudos, &work.Comments, &work.Bookmarks)

		// Convert to model fields
		if categoryStr.Valid && categoryStr.String != "" {
			work.Category = []string{categoryStr.String}
		}
		if warningsStr.Valid && warningsStr.String != "" {
			work.Warnings = []string{warningsStr.String}
		}
		work.Fandoms = []string(fandoms)
		work.Characters = []string(characters)
		work.Relationships = []string(relationships)
		work.FreeformTags = []string(freeformTags)
		if err != nil {
			fmt.Printf("SCAN ERROR: %v\n", err)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to scan work data", "details": err.Error()})
			return
		}
		works = append(works, work)
		fmt.Printf("Successfully scanned work: %s\n", work.Title)
	}
	fmt.Printf("Finished scanning. Found %d works\n", len(works))

	// Get total count
	countQuery := strings.Replace(baseQuery, "SELECT w.id, w.title, w.summary, w.user_id, u.username, w.language, w.rating, w.category, w.warnings, w.fandoms, w.characters, w.relationships, w.freeform_tags, w.word_count, w.chapter_count, w.max_chapters, w.is_complete, w.status, w.published_at, w.updated_at, w.created_at, COALESCE(ws.hits, 0) as hits, COALESCE(ws.kudos, 0) as kudos, COALESCE(ws.comments, 0) as comments, COALESCE(ws.bookmarks, 0) as bookmarks", "SELECT COUNT(*)", 1)
	countQuery = strings.Split(countQuery, "ORDER BY")[0] // Remove ORDER BY and LIMIT

	var total int
	err = ws.db.QueryRow(countQuery, args[:len(args)-2]...).Scan(&total) // Remove LIMIT and OFFSET args
	if err != nil {
		total = len(works) // Fallback
	}

	c.JSON(http.StatusOK, gin.H{
		"works": works,
		"pagination": gin.H{
			"page":  page,
			"limit": limit,
			"total": total,
			"pages": (total + limit - 1) / limit,
		},
	})
}

// Helper functions

func (ws *WorkService) getWorkByID(workID uuid.UUID) (*models.Work, error) {
	query := `
		SELECT w.id, w.title, w.summary, w.notes, w.user_id, u.username,
			w.language, w.rating, w.category, w.warnings, w.fandoms, w.characters, 
			w.relationships, w.freeform_tags, w.word_count, w.chapter_count, w.max_chapters,
			w.is_complete, w.status, w.published_at, w.updated_at, w.created_at,
			COALESCE(ws.hits, 0) as hits, COALESCE(ws.kudos, 0) as kudos,
			COALESCE(ws.comments, 0) as comments, COALESCE(ws.bookmarks, 0) as bookmarks
		FROM works w
		JOIN users u ON w.user_id = u.id
		LEFT JOIN work_statistics ws ON w.id = ws.work_id
		WHERE w.id = $1`

	var work models.Work
	var categoryArray, warningsArray, fandomsArray, charactersArray, relationshipsArray, freeformArray pq.StringArray

	err := ws.db.QueryRow(query, workID).Scan(
		&work.ID, &work.Title, &work.Summary, &work.Notes, &work.UserID, &work.Username,
		&work.Language, &work.Rating, &categoryArray,
		&warningsArray, &fandomsArray, &charactersArray,
		&relationshipsArray, &freeformArray, &work.WordCount,
		&work.ChapterCount, &work.MaxChapters, &work.IsComplete, &work.Status,
		&work.PublishedAt, &work.UpdatedAt, &work.CreatedAt,
		&work.Hits, &work.Kudos, &work.Comments, &work.Bookmarks)

	if err != nil {
		return nil, fmt.Errorf("DEBUG: Query error in getWorkByID: %v", err)
	}

	// Convert arrays to slices
	work.Category = []string(categoryArray)
	work.Warnings = []string(warningsArray)
	work.Fandoms = []string(fandomsArray)
	work.Characters = []string(charactersArray)
	work.Relationships = []string(relationshipsArray)
	work.FreeformTags = []string(freeformArray)

	// Set SeriesID to nil since it's not stored in works table
	work.SeriesID = nil

	return &work, nil
}

func (ws *WorkService) incrementHits(workID uuid.UUID) {
	// Increment hit counter asynchronously
	go func() {
		_, err := ws.db.Exec(`
			INSERT INTO work_statistics (work_id, hits, kudos, comments, bookmarks, collections, updated_at)
			VALUES ($1, 1, 0, 0, 0, 0, NOW())
			ON CONFLICT (work_id)
			DO UPDATE SET hits = work_statistics.hits + 1, updated_at = NOW()`,
			workID)
		if err != nil {
			// Log error but don't fail the request
			fmt.Printf("Failed to increment hits for work %s: %v\n", workID, err)
		}
	}()
}

func countWords(text string) int {
	// Simple word counting - would be more sophisticated in production
	fields := strings.Fields(strings.TrimSpace(text))
	return len(fields)
}

// Placeholder implementations for other handlers
// These would need full implementations in a real application

func (ws *WorkService) GetChapters(c *gin.Context) {
	log.Printf("GetChapters called for work_id: %s", c.Param("work_id"))

	// For now, just return empty chapters array to unblock work viewing
	c.JSON(http.StatusOK, gin.H{"chapters": []interface{}{}})
	return

	workID, err := uuid.Parse(c.Param("work_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid work ID"})
		return
	}

	// TODO: Re-enable permission check after debugging
	// Check if user can view this work
	// userID, hasUser := c.Get("user_id")
	// var userUUID *uuid.UUID
	// if hasUser {
	// 	userVal := userID.(uuid.UUID)
	// 	userUUID = &userVal
	// }

	// var canView bool
	// err = ws.db.QueryRow("SELECT can_user_view_work($1, $2)", workID, userUUID).Scan(&canView)
	// if err != nil {
	// 	log.Printf("Error checking work permissions for %s: %v", workID, err)
	// 	c.JSON(http.StatusInternalServerError, gin.H{"error": "Permission check failed"})
	// 	return
	// }
	// if !canView {
	// 	c.JSON(http.StatusForbidden, gin.H{"error": "Cannot view this work"})
	// 	return
	// }

	log.Printf("About to query chapters for work %s", workID)
	rows, err := ws.db.Query(`
		SELECT id, work_id, chapter_number, title, summary, notes, end_notes, 
			content, word_count, CASE WHEN is_draft THEN 'draft' ELSE 'posted' END as status, 
			published_at, created_at, updated_at
		FROM chapters 
		WHERE work_id = $1 
		ORDER BY chapter_number`, workID)
	if err != nil {
		log.Printf("Failed to fetch chapters for work %s: %v", workID, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch chapters", "details": err.Error()})
		return
	}
	defer rows.Close()

	chapters := []models.Chapter{}
	for rows.Next() {
		var chapter models.Chapter
		var publishedAt sql.NullTime
		err := rows.Scan(
			&chapter.ID, &chapter.WorkID, &chapter.Number, &chapter.Title, &chapter.Summary,
			&chapter.Notes, &chapter.EndNotes, &chapter.Content, &chapter.WordCount,
			&chapter.Status, &publishedAt, &chapter.CreatedAt, &chapter.UpdatedAt)
		if err != nil {
			log.Printf("Failed to scan chapter for work %s: %v", workID, err)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to scan chapter", "details": err.Error()})
			return
		}
		if publishedAt.Valid {
			chapter.PublishedAt = &publishedAt.Time
		}
		chapters = append(chapters, chapter)
	}

	c.JSON(http.StatusOK, gin.H{"chapters": chapters})
}

func (ws *WorkService) GetChapter(c *gin.Context) {
	workID, err := uuid.Parse(c.Param("work_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid work ID"})
		return
	}

	chapterNumber, err := strconv.Atoi(c.Param("chapter_number"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid chapter number"})
		return
	}

	// Check if user can view this work
	userID, hasUser := c.Get("user_id")
	var userUUID *uuid.UUID
	if hasUser {
		userVal := userID.(uuid.UUID)
		userUUID = &userVal
	}

	var canView bool
	err = ws.db.QueryRow("SELECT can_user_view_work($1, $2)", workID, userUUID).Scan(&canView)
	if err != nil || !canView {
		c.JSON(http.StatusForbidden, gin.H{"error": "Cannot view this work"})
		return
	}

	var chapter models.Chapter
	var publishedAt sql.NullTime

	err = ws.db.QueryRow(`
		SELECT id, work_id, chapter_number, title, summary, notes, end_notes, 
			content, word_count, CASE WHEN is_draft THEN 'draft' ELSE 'posted' END as status, 
			published_at, created_at, updated_at
		FROM chapters 
		WHERE work_id = $1 AND chapter_number = $2`, workID, chapterNumber).Scan(
		&chapter.ID, &chapter.WorkID, &chapter.Number, &chapter.Title, &chapter.Summary,
		&chapter.Notes, &chapter.EndNotes, &chapter.Content, &chapter.WordCount,
		&chapter.Status, &publishedAt, &chapter.CreatedAt, &chapter.UpdatedAt)

	if err == sql.ErrNoRows {
		c.JSON(http.StatusNotFound, gin.H{"error": "Chapter not found"})
		return
	}
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch chapter"})
		return
	}

	if publishedAt.Valid {
		chapter.PublishedAt = &publishedAt.Time
	}

	// Increment work hit count when chapter is viewed
	ws.incrementHits(workID)

	c.JSON(http.StatusOK, gin.H{"chapter": chapter})
}

func (ws *WorkService) CreateChapter(c *gin.Context) {
	workID, err := uuid.Parse(c.Param("work_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid work ID"})
		return
	}

	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	var req struct {
		Title    string `json:"title"`
		Summary  string `json:"summary"`
		Notes    string `json:"notes"`
		EndNotes string `json:"end_notes"`
		Content  string `json:"content" validate:"required"`
		Status   string `json:"status" validate:"oneof=draft posted"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request data", "details": err.Error()})
		return
	}

	// Verify ownership using creatorship system
	var isAuthor bool
	err = ws.db.QueryRow(`
		SELECT EXISTS(
			SELECT 1 FROM creatorships cr
			JOIN pseuds p ON cr.pseud_id = p.id
			WHERE cr.creation_id = $1 AND cr.creation_type = 'Work' 
			AND cr.approved = true AND p.user_id = $2
		)`, workID, userID).Scan(&isAuthor)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to verify ownership"})
		return
	}

	if !isAuthor {
		c.JSON(http.StatusForbidden, gin.H{"error": "Not authorized to add chapters to this work"})
		return
	}

	// Get next chapter number
	var nextNumber int
	err = ws.db.QueryRow("SELECT COALESCE(MAX(chapter_number), 0) + 1 FROM chapters WHERE work_id = $1", workID).Scan(&nextNumber)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get next chapter number"})
		return
	}

	// Create chapter
	chapterID := uuid.New()
	now := time.Now()
	wordCount := countWords(req.Content)

	chapter := &models.Chapter{
		ID:        chapterID,
		WorkID:    workID,
		Number:    nextNumber,
		Title:     req.Title,
		Summary:   req.Summary,
		Notes:     req.Notes,
		EndNotes:  req.EndNotes,
		Content:   req.Content,
		WordCount: wordCount,
		Status:    req.Status,
		CreatedAt: now,
		UpdatedAt: now,
	}

	if req.Status == "posted" {
		chapter.PublishedAt = &now
	}

	tx, err := ws.db.Begin()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to start transaction"})
		return
	}
	defer tx.Rollback()

	_, err = tx.Exec(`
		INSERT INTO chapters (id, work_id, chapter_number, title, summary, notes, end_notes, 
			content, word_count, is_draft, published_at, created_at, updated_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)`,
		chapter.ID, chapter.WorkID, chapter.Number, chapter.Title, chapter.Summary,
		chapter.Notes, chapter.EndNotes, chapter.Content, chapter.WordCount,
		chapter.Status == "draft", chapter.PublishedAt, chapter.CreatedAt, chapter.UpdatedAt)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create chapter", "details": err.Error()})
		return
	}

	// Update work statistics
	_, err = tx.Exec(`
		UPDATE works SET 
			chapter_count = (SELECT COUNT(*) FROM chapters WHERE work_id = $1),
			word_count = (SELECT COALESCE(SUM(word_count), 0) FROM chapters WHERE work_id = $1),
			updated_at = $2
		WHERE id = $1`, workID, now)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update work statistics"})
		return
	}

	if err = tx.Commit(); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to commit transaction"})
		return
	}

	c.JSON(http.StatusCreated, gin.H{"chapter": chapter})
}

func (ws *WorkService) UpdateChapter(c *gin.Context) {
	// TODO: Implement chapter updates
	c.JSON(http.StatusOK, gin.H{"chapter": gin.H{}})
}

func (ws *WorkService) DeleteChapter(c *gin.Context) {
	// TODO: Implement chapter deletion
	c.JSON(http.StatusOK, gin.H{"message": "Chapter deleted"})
}

func (ws *WorkService) GetComments(c *gin.Context) {
	workID, err := uuid.Parse(c.Param("work_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid work ID"})
		return
	}

	// Get user ID for moderation checks
	userID, hasUser := c.Get("user_id")
	var userUUID *uuid.UUID
	if hasUser {
		userIDStr := userID.(string)
		if userVal, err := uuid.Parse(userIDStr); err == nil {
			userUUID = &userVal
		}
	}

	// Check if user can view this work
	var canView bool
	err = ws.db.QueryRow("SELECT can_user_view_work($1, $2)", workID, userUUID).Scan(&canView)
	if err != nil || !canView {
		c.JSON(http.StatusForbidden, gin.H{"error": "Cannot view this work"})
		return
	}

	// Get work owner for moderation check
	var authorID uuid.UUID
	err = ws.db.QueryRow("SELECT user_id FROM works WHERE id = $1", workID).Scan(&authorID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get work info"})
		return
	}

	isAuthor := userUUID != nil && *userUUID == authorID

	// Build query - show different comments based on user role
	baseQuery := `
		SELECT c.id, c.work_id, c.chapter_id, c.user_id, c.parent_comment_id, c.content,
			c.status, c.is_anonymous, c.created_at, c.updated_at,
			COALESCE(u.username, 'Anonymous') as username
		FROM comments c
		LEFT JOIN users u ON c.user_id = u.id AND c.is_anonymous = false
		WHERE c.work_id = $1`

	// Authors can see all comments, others only see published ones
	if !isAuthor {
		baseQuery += " AND c.status = 'published'"
	}

	baseQuery += " ORDER BY c.created_at ASC"

	rows, err := ws.db.Query(baseQuery, workID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch comments"})
		return
	}
	defer rows.Close()

	comments := []models.WorkComment{}
	for rows.Next() {
		var comment models.WorkComment
		err := rows.Scan(
			&comment.ID, &comment.WorkID, &comment.ChapterID, &comment.UserID, &comment.ParentID,
			&comment.Content, &comment.Status, &comment.IsAnonymous, &comment.CreatedAt, &comment.UpdatedAt,
			&comment.Username)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to scan comment"})
			return
		}
		comments = append(comments, comment)
	}

	c.JSON(http.StatusOK, gin.H{"comments": comments})
}

func (ws *WorkService) CreateComment(c *gin.Context) {
	workID, err := uuid.Parse(c.Param("work_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid work ID"})
		return
	}

	var req struct {
		ChapterID   *uuid.UUID `json:"chapter_id"`
		ParentID    *uuid.UUID `json:"parent_id"`
		Content     string     `json:"content" validate:"required,max=10000"`
		IsAnonymous bool       `json:"is_anonymous"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request data", "details": err.Error()})
		return
	}

	// Get user ID (could be nil for anonymous comments)
	userID, hasUser := c.Get("user_id")
	var userUUID *uuid.UUID
	if hasUser {
		userVal := userID.(uuid.UUID)
		userUUID = &userVal
	}

	// Check if user can comment on this work
	var canComment bool
	err = ws.db.QueryRow("SELECT can_user_comment_on_work($1, $2)", workID, userUUID).Scan(&canComment)
	if err != nil || !canComment {
		c.JSON(http.StatusForbidden, gin.H{"error": "Cannot comment on this work"})
		return
	}

	// Get work's comment policy
	var commentPolicy string
	var moderateComments bool
	var authorID uuid.UUID
	err = ws.db.QueryRow(`
		SELECT comment_policy, moderate_comments, user_id 
		FROM works 
		WHERE id = $1`, workID).Scan(&commentPolicy, &moderateComments, &authorID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check work settings"})
		return
	}

	// Check if commenter is blocked by author
	if userUUID != nil {
		var isBlocked bool
		err = ws.db.QueryRow(`
			SELECT EXISTS(
				SELECT 1 FROM user_blocks 
				WHERE blocker_id = $1 AND blocked_id = $2 
				AND block_type IN ('full', 'comments')
			)`, authorID, *userUUID).Scan(&isBlocked)
		if err == nil && isBlocked {
			c.JSON(http.StatusForbidden, gin.H{"error": "You are blocked from commenting on this author's works"})
			return
		}
	}

	// Get client IP for anonymous comments
	clientIP := c.ClientIP()

	// Determine comment status based on moderation settings
	status := "published"
	if moderateComments {
		status = "pending"
	}

	// Create comment
	commentID := uuid.New()
	now := time.Now()

	comment := &models.WorkComment{
		ID:          commentID,
		WorkID:      workID,
		ChapterID:   req.ChapterID,
		UserID:      userUUID,
		ParentID:    req.ParentID,
		Content:     req.Content,
		Status:      status,
		IsAnonymous: req.IsAnonymous,
		IPAddress:   clientIP,
		CreatedAt:   now,
		UpdatedAt:   now,
	}

	query := `
		INSERT INTO comments (id, work_id, chapter_id, user_id, parent_comment_id, content, 
			status, is_anonymous, ip_address, created_at, updated_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)`

	_, err = ws.db.Exec(query,
		comment.ID, comment.WorkID, comment.ChapterID, comment.UserID, comment.ParentID,
		comment.Content, comment.Status, comment.IsAnonymous, comment.IPAddress,
		comment.CreatedAt, comment.UpdatedAt)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create comment", "details": err.Error()})
		return
	}

	// Get username for response
	if userUUID != nil && !req.IsAnonymous {
		ws.db.QueryRow("SELECT username FROM users WHERE id = $1", *userUUID).Scan(&comment.Username)
	} else {
		comment.Username = "Anonymous"
	}

	responseData := gin.H{"comment": comment}
	if status == "pending" {
		responseData["message"] = "Comment submitted for moderation"
	}

	c.JSON(http.StatusCreated, responseData)
}

func (ws *WorkService) UpdateComment(c *gin.Context) {
	// TODO: Implement comment updates
	c.JSON(http.StatusOK, gin.H{"comment": gin.H{}})
}

func (ws *WorkService) DeleteComment(c *gin.Context) {
	// TODO: Implement comment deletion
	c.JSON(http.StatusOK, gin.H{"message": "Comment deleted"})
}

func (ws *WorkService) GetKudos(c *gin.Context) {
	// TODO: Implement kudos listing
	c.JSON(http.StatusOK, gin.H{"kudos": []gin.H{}})
}

func (ws *WorkService) GiveKudos(c *gin.Context) {
	workID, err := uuid.Parse(c.Param("work_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid work ID"})
		return
	}

	// Get user ID (could be nil for anonymous kudos)
	userID, hasUser := c.Get("user_id")
	var userUUID *uuid.UUID
	if hasUser {
		userVal := userID.(uuid.UUID)
		userUUID = &userVal
	}

	// Check if user can view this work
	var canView bool
	err = ws.db.QueryRow("SELECT can_user_view_work($1, $2)", workID, userUUID).Scan(&canView)
	if err != nil || !canView {
		c.JSON(http.StatusForbidden, gin.H{"error": "Cannot give kudos to this work"})
		return
	}

	// Check if work allows kudos from this user
	var allowKudos bool
	if userUUID != nil {
		// Logged in user - check if they've already given kudos
		err = ws.db.QueryRow(`
			SELECT NOT EXISTS(
				SELECT 1 FROM kudos 
				WHERE work_id = $1 AND user_id = $2
			)`, workID, *userUUID).Scan(&allowKudos)
	} else {
		// Anonymous user - check IP address
		clientIP := c.ClientIP()
		err = ws.db.QueryRow(`
			SELECT NOT EXISTS(
				SELECT 1 FROM kudos 
				WHERE work_id = $1 AND ip_address = $2 AND user_id IS NULL
			)`, workID, clientIP).Scan(&allowKudos)
	}

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check kudos eligibility"})
		return
	}

	if !allowKudos {
		c.JSON(http.StatusConflict, gin.H{"error": "You have already given kudos to this work"})
		return
	}

	// Check if user is the author (can't give kudos to own work)
	if userUUID != nil {
		var isAuthor bool
		err = ws.db.QueryRow(`
			SELECT EXISTS(
				SELECT 1 FROM creatorships cr
				JOIN pseuds p ON cr.pseud_id = p.id
				WHERE cr.creation_id = $1 AND cr.creation_type = 'Work' 
				AND cr.approved = true AND p.user_id = $2
			)`, workID, *userUUID).Scan(&isAuthor)

		if err == nil && isAuthor {
			c.JSON(http.StatusForbidden, gin.H{"error": "Cannot give kudos to your own work"})
			return
		}
	}

	// Give kudos
	kudosID := uuid.New()
	now := time.Now()
	clientIP := c.ClientIP()

	_, err = ws.db.Exec(`
		INSERT INTO kudos (id, work_id, user_id, ip_address, created_at)
		VALUES ($1, $2, $3, $4, $5)`,
		kudosID, workID, userUUID, clientIP, now)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to give kudos"})
		return
	}

	// Update work kudos count
	_, err = ws.db.Exec(`
		UPDATE works SET 
			kudos_count = (SELECT COUNT(*) FROM kudos WHERE work_id = $1),
			updated_at = $2
		WHERE id = $1`, workID, now)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update kudos count"})
		return
	}

	c.JSON(http.StatusCreated, gin.H{"message": "Kudos given successfully"})
}

func (ws *WorkService) RemoveKudos(c *gin.Context) {
	// TODO: Implement kudos removal
	c.JSON(http.StatusOK, gin.H{"message": "Kudos removed"})
}

func (ws *WorkService) GetStats(c *gin.Context) {
	// TODO: Implement statistics retrieval
	c.JSON(http.StatusOK, gin.H{"stats": gin.H{}})
}

func (ws *WorkService) SearchSeries(c *gin.Context) {
	query := c.Query("q")
	if query == "" {
		// Return recent series if no search query
		query = "%"
	} else {
		query = "%" + query + "%"
	}

	// Build pagination
	page := 1
	if pageStr := c.Query("page"); pageStr != "" {
		if p, err := strconv.Atoi(pageStr); err == nil && p > 0 {
			page = p
		}
	}

	limit := 20
	if limitStr := c.Query("limit"); limitStr != "" {
		if l, err := strconv.Atoi(limitStr); err == nil && l > 0 && l <= 100 {
			limit = l
		}
	}

	offset := (page - 1) * limit

	// Search series by title and summary
	searchQuery := `
		SELECT s.id, s.title, s.description, s.notes, s.user_id, s.is_complete,
			s.work_count, s.created_at, s.updated_at, u.username
		FROM series s
		JOIN users u ON s.user_id = u.id
		WHERE (s.title ILIKE $1 OR s.description ILIKE $1)
		ORDER BY s.updated_at DESC
		LIMIT $2 OFFSET $3`

	rows, err := ws.db.Query(searchQuery, query, limit, offset)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to search series"})
		return
	}
	defer rows.Close()

	var series []models.Series
	for rows.Next() {
		var s models.Series
		err := rows.Scan(
			&s.ID, &s.Title, &s.Summary, &s.Notes, &s.UserID, &s.IsComplete,
			&s.WorkCount, &s.CreatedAt, &s.UpdatedAt, &s.Username)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to scan series"})
			return
		}

		// Calculate word count for each series
		ws.db.QueryRow(`
			SELECT COALESCE(SUM(w.word_count), 0) 
			FROM works w 
			JOIN series_works sw ON w.id = sw.work_id
			WHERE sw.series_id = $1 AND w.status != 'draft'`, s.ID).Scan(&s.WordCount)

		series = append(series, s)
	}

	// Get total count for pagination
	var total int
	countQuery := `
		SELECT COUNT(*) 
		FROM series s
		WHERE (s.title ILIKE $1 OR s.description ILIKE $1)`
	err = ws.db.QueryRow(countQuery, query).Scan(&total)
	if err != nil {
		total = len(series) // Fallback
	}

	c.JSON(http.StatusOK, gin.H{
		"series": series,
		"pagination": gin.H{
			"page":        page,
			"limit":       limit,
			"total":       total,
			"total_pages": (total + limit - 1) / limit,
		},
	})
}

func (ws *WorkService) GetSeries(c *gin.Context) {
	seriesID, err := uuid.Parse(c.Param("series_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid series ID"})
		return
	}

	var series models.Series
	err = ws.db.QueryRow(`
		SELECT s.id, s.title, s.summary, s.notes, s.user_id, s.is_complete, 
			s.work_count, s.created_at, s.updated_at, u.username
		FROM series s
		JOIN users u ON s.user_id = u.id
		WHERE s.id = $1`, seriesID).Scan(
		&series.ID, &series.Title, &series.Summary, &series.Notes, &series.UserID,
		&series.IsComplete, &series.WorkCount, &series.CreatedAt, &series.UpdatedAt,
		&series.Username)

	if err == sql.ErrNoRows {
		c.JSON(http.StatusNotFound, gin.H{"error": "Series not found"})
		return
	}
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch series"})
		return
	}

	// Calculate total word count from works
	err = ws.db.QueryRow(`
		SELECT COALESCE(SUM(w.word_count), 0)
		FROM works w
		JOIN series_works sw ON w.id = sw.work_id
		WHERE sw.series_id = $1 AND w.status != 'draft'`, seriesID).Scan(&series.WordCount)

	if err != nil {
		series.WordCount = 0 // Fallback
	}

	c.JSON(http.StatusOK, gin.H{"series": series})
}

func (ws *WorkService) GetSeriesWorks(c *gin.Context) {
	seriesID, err := uuid.Parse(c.Param("series_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid series ID"})
		return
	}

	// Get user ID for privacy checks
	userID, hasUser := c.Get("user_id")
	var userUUID *uuid.UUID
	if hasUser {
		userVal := userID.(uuid.UUID)
		userUUID = &userVal
	}

	baseQuery := `
		SELECT w.id, w.title, w.summary, w.language, w.rating,
			w.category, w.warnings, w.fandoms, w.characters, w.relationships, w.freeform_tags,
			w.word_count, w.chapter_count, w.max_chapters, w.is_complete, w.status,
			w.published_at, w.updated_at, w.created_at,
			COALESCE(w.hit_count, 0) as hits, COALESCE(w.kudos_count, 0) as kudos,
			COALESCE(w.comment_count, 0) as comments, COALESCE(w.bookmark_count, 0) as bookmarks,
			sw.position
		FROM works w
		JOIN series_works sw ON w.id = sw.work_id
		WHERE sw.series_id = $1`

	// If no user, only show non-draft, non-restricted works
	if !hasUser {
		baseQuery += " AND w.status != 'draft' AND w.restricted_to_users = false"
	}

	baseQuery += " ORDER BY sw.position"

	rows, err := ws.db.Query(baseQuery, seriesID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch series works"})
		return
	}
	defer rows.Close()

	works := []interface{}{}
	for rows.Next() {
		var work models.Work
		var categoryStr, warningsStr sql.NullString
		var fandoms, characters, relationships, freeformTags pq.StringArray
		var summary sql.NullString
		var publishedAt sql.NullTime
		var status sql.NullString
		var maxChapters sql.NullInt64
		var position int

		err := rows.Scan(
			&work.ID, &work.Title, &summary,
			&work.Language, &work.Rating, &categoryStr, &warningsStr,
			&fandoms, &characters, &relationships, &freeformTags,
			&work.WordCount, &work.ChapterCount, &maxChapters,
			&work.IsComplete, &status, &publishedAt, &work.UpdatedAt, &work.CreatedAt,
			&work.Hits, &work.Kudos, &work.Comments, &work.Bookmarks,
			&position)

		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to scan work"})
			return
		}

		// Handle nullable fields
		if summary.Valid {
			work.Summary = summary.String
		}
		if publishedAt.Valid {
			work.PublishedAt = &publishedAt.Time
		}
		if maxChapters.Valid {
			maxChapInt := int(maxChapters.Int64)
			work.MaxChapters = &maxChapInt
		}
		if status.Valid {
			work.Status = status.String
		}

		// Convert string fields to arrays
		if categoryStr.Valid && categoryStr.String != "" {
			work.Category = []string{categoryStr.String}
		}
		if warningsStr.Valid && warningsStr.String != "" {
			work.Warnings = []string{warningsStr.String}
		}
		work.Fandoms = []string(fandoms)
		work.Characters = []string(characters)
		work.Relationships = []string(relationships)
		work.FreeformTags = []string(freeformTags)

		// Check if user can view this specific work
		if userUUID != nil {
			var canView bool
			err = ws.db.QueryRow("SELECT can_user_view_work($1, $2)", work.ID, *userUUID).Scan(&canView)
			if err != nil || !canView {
				continue // Skip this work
			}
		}

		workData := gin.H{
			"work":     work,
			"position": position,
		}

		works = append(works, workData)
	}

	c.JSON(http.StatusOK, gin.H{"works": works})
}

func (ws *WorkService) CreateSeries(c *gin.Context) {
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	var req struct {
		Title      string   `json:"title" validate:"required,min=1,max=500"`
		Summary    string   `json:"summary"`
		Notes      string   `json:"notes"`
		IsComplete bool     `json:"is_complete"`
		WorkIDs    []string `json:"work_ids"` // Works to add to series
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request data", "details": err.Error()})
		return
	}

	userUUID := userID.(uuid.UUID)

	// Verify user owns all specified works
	if len(req.WorkIDs) > 0 {
		for _, workIDStr := range req.WorkIDs {
			workID, err := uuid.Parse(workIDStr)
			if err != nil {
				c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid work ID format"})
				return
			}

			var isAuthor bool
			err = ws.db.QueryRow(`
				SELECT EXISTS(
					SELECT 1 FROM creatorships cr
					JOIN pseuds p ON cr.pseud_id = p.id
					WHERE cr.creation_id = $1 AND cr.creation_type = 'Work' 
					AND cr.approved = true AND p.user_id = $2
				)`, workID, userUUID).Scan(&isAuthor)

			if err != nil || !isAuthor {
				c.JSON(http.StatusForbidden, gin.H{"error": "You can only add your own works to a series"})
				return
			}
		}
	}

	// Create series
	seriesID := uuid.New()
	now := time.Now()

	tx, err := ws.db.Begin()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to start transaction"})
		return
	}
	defer tx.Rollback()

	series := &models.Series{
		ID:         seriesID,
		Title:      req.Title,
		Summary:    req.Summary,
		Notes:      req.Notes,
		UserID:     userUUID,
		IsComplete: req.IsComplete,
		WorkCount:  len(req.WorkIDs),
		CreatedAt:  now,
		UpdatedAt:  now,
	}

	_, err = tx.Exec(`
		INSERT INTO series (id, title, summary, notes, user_id, is_complete, work_count, created_at, updated_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`,
		series.ID, series.Title, series.Summary, series.Notes, series.UserID,
		series.IsComplete, series.WorkCount, series.CreatedAt, series.UpdatedAt)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create series"})
		return
	}

	// Add works to series
	for i, workIDStr := range req.WorkIDs {
		workID, _ := uuid.Parse(workIDStr)
		_, err = tx.Exec(`
			INSERT INTO series_works (series_id, work_id, position, created_at)
			VALUES ($1, $2, $3, $4)`,
			seriesID, workID, i+1, now)

		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to add work to series"})
			return
		}

		// Update work to reference series
		_, err = tx.Exec("UPDATE works SET series_id = $1, updated_at = $2 WHERE id = $3", seriesID, now, workID)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update work series reference"})
			return
		}
	}

	if err = tx.Commit(); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to commit transaction"})
		return
	}

	c.JSON(http.StatusCreated, gin.H{"series": series})
}

func (ws *WorkService) UpdateSeries(c *gin.Context) {
	seriesID, err := uuid.Parse(c.Param("series_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid series ID"})
		return
	}

	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	var req struct {
		Title      string `json:"title" binding:"required,max=500"`
		Summary    string `json:"summary"`
		Notes      string `json:"notes"`
		IsComplete bool   `json:"is_complete"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request data", "details": err.Error()})
		return
	}

	// Verify user owns the series
	var ownerID uuid.UUID
	err = ws.db.QueryRow("SELECT user_id FROM series WHERE id = $1", seriesID).Scan(&ownerID)
	if err == sql.ErrNoRows {
		c.JSON(http.StatusNotFound, gin.H{"error": "Series not found"})
		return
	}
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to verify series ownership"})
		return
	}

	if ownerID != userID {
		c.JSON(http.StatusForbidden, gin.H{"error": "You can only update your own series"})
		return
	}

	// Update series
	now := time.Now()
	_, err = ws.db.Exec(`
		UPDATE series 
		SET title = $1, description = $2, notes = $3, is_complete = $4, updated_at = $5
		WHERE id = $6`,
		req.Title, req.Summary, req.Notes, req.IsComplete, now, seriesID)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update series"})
		return
	}

	// Fetch updated series
	var series models.Series
	var username string
	err = ws.db.QueryRow(`
		SELECT s.id, s.title, s.description, s.notes, s.user_id, s.is_complete,
			s.work_count, s.created_at, s.updated_at, u.username
		FROM series s
		JOIN users u ON s.user_id = u.id
		WHERE s.id = $1`, seriesID).Scan(
		&series.ID, &series.Title, &series.Summary, &series.Notes, &series.UserID,
		&series.IsComplete, &series.WorkCount, &series.CreatedAt, &series.UpdatedAt, &username)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch updated series"})
		return
	}

	series.Username = username
	c.JSON(http.StatusOK, gin.H{"series": series})
}

func (ws *WorkService) DeleteSeries(c *gin.Context) {
	seriesID, err := uuid.Parse(c.Param("series_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid series ID"})
		return
	}

	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	// Verify user owns the series
	var ownerID uuid.UUID
	err = ws.db.QueryRow("SELECT user_id FROM series WHERE id = $1", seriesID).Scan(&ownerID)
	if err == sql.ErrNoRows {
		c.JSON(http.StatusNotFound, gin.H{"error": "Series not found"})
		return
	}
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to verify series ownership"})
		return
	}

	if ownerID != userID {
		c.JSON(http.StatusForbidden, gin.H{"error": "You can only delete your own series"})
		return
	}

	tx, err := ws.db.Begin()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to start transaction"})
		return
	}
	defer tx.Rollback()

	// Remove series reference from works
	_, err = tx.Exec("UPDATE works SET series_id = NULL WHERE series_id = $1", seriesID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update works"})
		return
	}

	// Delete series (series_works will be deleted by CASCADE)
	result, err := tx.Exec("DELETE FROM series WHERE id = $1", seriesID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete series"})
		return
	}

	rowsAffected, _ := result.RowsAffected()
	if rowsAffected == 0 {
		c.JSON(http.StatusNotFound, gin.H{"error": "Series not found"})
		return
	}

	if err = tx.Commit(); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to commit transaction"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Series deleted successfully"})
}

func (ws *WorkService) AddWorkToSeries(c *gin.Context) {
	seriesID, err := uuid.Parse(c.Param("series_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid series ID"})
		return
	}

	workID, err := uuid.Parse(c.Param("work_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid work ID"})
		return
	}

	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	var req struct {
		Position int `json:"position"` // Optional, will be appended if not provided
	}
	c.ShouldBindJSON(&req)

	tx, err := ws.db.Begin()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to start transaction"})
		return
	}
	defer tx.Rollback()

	// Verify user owns the series
	var seriesOwnerID uuid.UUID
	err = tx.QueryRow("SELECT user_id FROM series WHERE id = $1", seriesID).Scan(&seriesOwnerID)
	if err == sql.ErrNoRows {
		c.JSON(http.StatusNotFound, gin.H{"error": "Series not found"})
		return
	}
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to verify series ownership"})
		return
	}

	// Verify user owns the work
	var workOwnerID uuid.UUID
	err = tx.QueryRow("SELECT user_id FROM works WHERE id = $1", workID).Scan(&workOwnerID)
	if err == sql.ErrNoRows {
		c.JSON(http.StatusNotFound, gin.H{"error": "Work not found"})
		return
	}
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to verify work ownership"})
		return
	}

	if seriesOwnerID != userID || workOwnerID != userID {
		c.JSON(http.StatusForbidden, gin.H{"error": "You can only add your own works to your own series"})
		return
	}

	// Check if work is already in series
	var existingCount int
	err = tx.QueryRow("SELECT COUNT(*) FROM series_works WHERE series_id = $1 AND work_id = $2", seriesID, workID).Scan(&existingCount)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check existing relationship"})
		return
	}
	if existingCount > 0 {
		c.JSON(http.StatusConflict, gin.H{"error": "Work is already in this series"})
		return
	}

	// Determine position
	var position int
	if req.Position > 0 {
		position = req.Position
		// Shift existing works to make room
		_, err = tx.Exec("UPDATE series_works SET position = position + 1 WHERE series_id = $1 AND position >= $2", seriesID, position)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update work positions"})
			return
		}
	} else {
		// Append to end
		err = tx.QueryRow("SELECT COALESCE(MAX(position), 0) + 1 FROM series_works WHERE series_id = $1", seriesID).Scan(&position)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to determine position"})
			return
		}
	}

	// Add work to series
	now := time.Now()
	_, err = tx.Exec("INSERT INTO series_works (series_id, work_id, position, created_at) VALUES ($1, $2, $3, $4)",
		seriesID, workID, position, now)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to add work to series"})
		return
	}

	// Update work's series reference
	_, err = tx.Exec("UPDATE works SET series_id = $1, updated_at = $2 WHERE id = $3", seriesID, now, workID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update work series reference"})
		return
	}

	// Update series work count
	_, err = tx.Exec("UPDATE series SET work_count = (SELECT COUNT(*) FROM series_works WHERE series_id = $1), updated_at = $2 WHERE id = $1", seriesID, now)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update series work count"})
		return
	}

	if err = tx.Commit(); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to commit transaction"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Work added to series successfully", "position": position})
}

func (ws *WorkService) RemoveWorkFromSeries(c *gin.Context) {
	seriesID, err := uuid.Parse(c.Param("series_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid series ID"})
		return
	}

	workID, err := uuid.Parse(c.Param("work_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid work ID"})
		return
	}

	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	tx, err := ws.db.Begin()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to start transaction"})
		return
	}
	defer tx.Rollback()

	// Verify user owns the series and work
	var seriesOwnerID, workOwnerID uuid.UUID
	var position int
	err = tx.QueryRow(`
		SELECT s.user_id, w.user_id, sw.position 
		FROM series s, works w, series_works sw 
		WHERE s.id = $1 AND w.id = $2 AND sw.series_id = $1 AND sw.work_id = $2`,
		seriesID, workID).Scan(&seriesOwnerID, &workOwnerID, &position)

	if err == sql.ErrNoRows {
		c.JSON(http.StatusNotFound, gin.H{"error": "Work not found in this series"})
		return
	}
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to verify ownership"})
		return
	}

	if seriesOwnerID != userID || workOwnerID != userID {
		c.JSON(http.StatusForbidden, gin.H{"error": "You can only remove your own works from your own series"})
		return
	}

	// Remove work from series
	_, err = tx.Exec("DELETE FROM series_works WHERE series_id = $1 AND work_id = $2", seriesID, workID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to remove work from series"})
		return
	}

	// Update work's series reference
	now := time.Now()
	_, err = tx.Exec("UPDATE works SET series_id = NULL, updated_at = $1 WHERE id = $2", now, workID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update work series reference"})
		return
	}

	// Reorder remaining works to close the gap
	_, err = tx.Exec("UPDATE series_works SET position = position - 1 WHERE series_id = $1 AND position > $2", seriesID, position)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to reorder works"})
		return
	}

	// Update series work count
	_, err = tx.Exec("UPDATE series SET work_count = (SELECT COUNT(*) FROM series_works WHERE series_id = $1), updated_at = $2 WHERE id = $1", seriesID, now)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update series work count"})
		return
	}

	if err = tx.Commit(); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to commit transaction"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Work removed from series successfully"})
}

func (ws *WorkService) SearchCollections(c *gin.Context) {
	// TODO: Implement collection search
	c.JSON(http.StatusOK, gin.H{"collections": []gin.H{}})
}

func (ws *WorkService) GetCollection(c *gin.Context) {
	collectionID, err := uuid.Parse(c.Param("collection_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid collection ID"})
		return
	}

	var collection models.Collection
	var username string
	err = ws.db.QueryRow(`
		SELECT c.id, c.name, c.title, c.description, c.user_id, c.is_open, 
			c.is_moderated, c.is_anonymous, c.work_count, c.created_at, c.updated_at,
			u.username
		FROM collections c
		JOIN users u ON c.user_id = u.id
		WHERE c.id = $1`, collectionID).Scan(
		&collection.ID, &collection.Name, &collection.Title, &collection.Description,
		&collection.UserID, &collection.IsOpen, &collection.IsModerated, &collection.IsAnonymous,
		&collection.WorkCount, &collection.CreatedAt, &collection.UpdatedAt, &username)

	if err == sql.ErrNoRows {
		c.JSON(http.StatusNotFound, gin.H{"error": "Collection not found"})
		return
	}
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch collection"})
		return
	}

	response := gin.H{
		"collection": collection,
		"maintainer": username,
	}

	c.JSON(http.StatusOK, response)
}

func (ws *WorkService) GetCollectionWorks(c *gin.Context) {
	// TODO: Implement collection works listing
	c.JSON(http.StatusOK, gin.H{"works": []gin.H{}})
}

func (ws *WorkService) CreateCollection(c *gin.Context) {
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	var req struct {
		Name        string `json:"name" validate:"required,min=1,max=100"`
		Title       string `json:"title" validate:"required,min=1,max=200"`
		Description string `json:"description"`
		IsOpen      bool   `json:"is_open"`
		IsModerated bool   `json:"is_moderated"`
		IsAnonymous bool   `json:"is_anonymous"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request data", "details": err.Error()})
		return
	}

	userUUID := userID.(uuid.UUID)

	// Check if collection name is unique
	var existingID uuid.UUID
	err := ws.db.QueryRow("SELECT id FROM collections WHERE name = $1", req.Name).Scan(&existingID)
	if err == nil {
		c.JSON(http.StatusConflict, gin.H{"error": "Collection name already exists"})
		return
	}

	// Create collection
	collectionID := uuid.New()
	now := time.Now()

	collection := &models.Collection{
		ID:          collectionID,
		Name:        req.Name,
		Title:       req.Title,
		Description: req.Description,
		UserID:      userUUID,
		IsOpen:      req.IsOpen,
		IsModerated: req.IsModerated,
		IsAnonymous: req.IsAnonymous,
		WorkCount:   0,
		CreatedAt:   now,
		UpdatedAt:   now,
	}

	_, err = ws.db.Exec(`
		INSERT INTO collections (id, name, title, description, user_id, is_open, is_moderated, is_anonymous, work_count, created_at, updated_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)`,
		collection.ID, collection.Name, collection.Title, collection.Description, collection.UserID,
		collection.IsOpen, collection.IsModerated, collection.IsAnonymous, collection.WorkCount,
		collection.CreatedAt, collection.UpdatedAt)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create collection"})
		return
	}

	c.JSON(http.StatusCreated, gin.H{"collection": collection})
}

func (ws *WorkService) UpdateCollection(c *gin.Context) {
	// TODO: Implement collection updates
	c.JSON(http.StatusOK, gin.H{"collection": gin.H{}})
}

func (ws *WorkService) DeleteCollection(c *gin.Context) {
	// TODO: Implement collection deletion
	c.JSON(http.StatusOK, gin.H{"message": "Collection deleted"})
}

func (ws *WorkService) AddWorkToCollection(c *gin.Context) {
	collectionID, err := uuid.Parse(c.Param("collection_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid collection ID"})
		return
	}

	workID, err := uuid.Parse(c.Param("work_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid work ID"})
		return
	}

	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	userUUID := userID.(uuid.UUID)

	// Get collection settings
	var collection models.Collection
	err = ws.db.QueryRow(`
		SELECT id, user_id, is_open, is_moderated
		FROM collections WHERE id = $1`, collectionID).Scan(
		&collection.ID, &collection.UserID, &collection.IsOpen, &collection.IsModerated)

	if err == sql.ErrNoRows {
		c.JSON(http.StatusNotFound, gin.H{"error": "Collection not found"})
		return
	}
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch collection"})
		return
	}

	// Check permissions - either collection maintainer, work author, or open collection
	var canAdd bool
	var isWorkAuthor bool

	// Check if user is collection maintainer
	isMaintainer := collection.UserID == userUUID

	// Check if user is work author
	err = ws.db.QueryRow(`
		SELECT EXISTS(
			SELECT 1 FROM creatorships cr
			JOIN pseuds p ON cr.pseud_id = p.id
			WHERE cr.creation_id = $1 AND cr.creation_type = 'Work' 
			AND cr.approved = true AND p.user_id = $2
		)`, workID, userUUID).Scan(&isWorkAuthor)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check work authorship"})
		return
	}

	canAdd = isMaintainer || (collection.IsOpen && isWorkAuthor)

	if !canAdd {
		c.JSON(http.StatusForbidden, gin.H{"error": "Cannot add work to this collection"})
		return
	}

	// Check if work is already in collection
	var existingItemID uuid.UUID
	err = ws.db.QueryRow("SELECT id FROM collection_items WHERE collection_id = $1 AND work_id = $2", collectionID, workID).Scan(&existingItemID)
	if err == nil {
		c.JSON(http.StatusConflict, gin.H{"error": "Work is already in this collection"})
		return
	}

	// Add work to collection
	itemID := uuid.New()
	now := time.Now()
	isApproved := !collection.IsModerated || isMaintainer

	var approvedAt *time.Time
	if isApproved {
		approvedAt = &now
	}

	_, err = ws.db.Exec(`
		INSERT INTO collection_items (id, collection_id, work_id, added_by, is_approved, added_at, approved_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7)`,
		itemID, collectionID, workID, userUUID, isApproved, now, approvedAt)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to add work to collection"})
		return
	}

	// Update collection work count if approved
	if isApproved {
		_, err = ws.db.Exec(`
			UPDATE collections SET 
				work_count = (SELECT COUNT(*) FROM collection_items WHERE collection_id = $1 AND is_approved = true),
				updated_at = $2
			WHERE id = $1`, collectionID, now)

		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update collection count"})
			return
		}
	}

	message := "Work added to collection"
	if !isApproved {
		message = "Work submitted to collection for approval"
	}

	c.JSON(http.StatusCreated, gin.H{"message": message})
}

func (ws *WorkService) RemoveWorkFromCollection(c *gin.Context) {
	// TODO: Implement removing work from collection
	c.JSON(http.StatusOK, gin.H{"message": "Work removed from collection"})
}

func (ws *WorkService) GetUserWorks(c *gin.Context) {
	// TODO: Implement user works listing
	c.JSON(http.StatusOK, gin.H{"works": []gin.H{}})
}

func (ws *WorkService) GetUserSeries(c *gin.Context) {
	userIDParam := c.Param("user_id")
	targetUserID, err := uuid.Parse(userIDParam)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
		return
	}

	// Build query with pagination
	page := 1
	if pageStr := c.Query("page"); pageStr != "" {
		if p, err := strconv.Atoi(pageStr); err == nil && p > 0 {
			page = p
		}
	}

	limit := 20
	if limitStr := c.Query("limit"); limitStr != "" {
		if l, err := strconv.Atoi(limitStr); err == nil && l > 0 && l <= 100 {
			limit = l
		}
	}

	offset := (page - 1) * limit

	query := `
		SELECT s.id, s.title, s.description, s.notes, s.user_id, s.is_complete,
			s.work_count, s.created_at, s.updated_at, u.username
		FROM series s
		JOIN users u ON s.user_id = u.id
		WHERE s.user_id = $1
		ORDER BY s.updated_at DESC
		LIMIT $2 OFFSET $3`

	rows, err := ws.db.Query(query, targetUserID, limit, offset)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch user series"})
		return
	}
	defer rows.Close()

	var series []models.Series
	for rows.Next() {
		var s models.Series
		err := rows.Scan(
			&s.ID, &s.Title, &s.Summary, &s.Notes, &s.UserID, &s.IsComplete,
			&s.WorkCount, &s.CreatedAt, &s.UpdatedAt, &s.Username)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to scan series"})
			return
		}

		// Calculate word count for each series
		ws.db.QueryRow(`
			SELECT COALESCE(SUM(w.word_count), 0) 
			FROM works w 
			JOIN series_works sw ON w.id = sw.work_id
			WHERE sw.series_id = $1 AND w.status != 'draft'`, s.ID).Scan(&s.WordCount)

		series = append(series, s)
	}

	// Get total count for pagination
	var total int
	err = ws.db.QueryRow("SELECT COUNT(*) FROM series WHERE user_id = $1", targetUserID).Scan(&total)
	if err != nil {
		total = len(series) // Fallback
	}

	c.JSON(http.StatusOK, gin.H{
		"series": series,
		"pagination": gin.H{
			"page":        page,
			"limit":       limit,
			"total":       total,
			"total_pages": (total + limit - 1) / limit,
		},
	})
}

func (ws *WorkService) GetUserBookmarks(c *gin.Context) {
	userIDParam := c.Param("user_id")
	targetUserID, err := uuid.Parse(userIDParam)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
		return
	}

	// Get authenticated user (may be nil for guest viewing)
	var viewerID *uuid.UUID
	if userID, exists := c.Get("user_id"); exists {
		uid := userID.(uuid.UUID)
		viewerID = &uid
	}

	// Build query to get user's bookmarks
	query := `
		SELECT b.id, b.work_id, b.notes, b.tags, b.is_private, b.created_at, b.updated_at,
			   w.title, w.summary, w.rating, w.fandoms, w.characters, w.relationships, 
			   w.freeform_tags, w.word_count, w.chapter_count, w.is_complete, w.status,
			   w.published_at, w.updated_at as work_updated_at,
			   COALESCE(ws.hits, 0) as hits, COALESCE(ws.kudos, 0) as kudos,
			   COALESCE(ws.comments, 0) as comments, COALESCE(ws.bookmarks, 0) as bookmarks
		FROM bookmarks b
		JOIN works w ON b.work_id = w.id
		LEFT JOIN work_statistics ws ON w.id = ws.work_id
		WHERE b.user_id = $1`

	args := []interface{}{targetUserID}

	// If viewer is not the bookmark owner, only show public bookmarks
	if viewerID == nil || *viewerID != targetUserID {
		query += " AND b.is_private = false"
	}

	// Only show works the viewer can access
	if viewerID != nil {
		query += " AND can_user_view_work(w.id, $2)"
		args = append(args, *viewerID)
	} else {
		query += " AND w.restricted_to_users = false AND w.status = 'posted'"
	}

	query += " ORDER BY b.created_at DESC"

	rows, err := ws.db.Query(query, args...)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch bookmarks"})
		return
	}
	defer rows.Close()

	var bookmarks []gin.H
	for rows.Next() {
		var b models.Bookmark
		var w models.Work
		var hits, kudos, comments, bookmarkCount int

		err := rows.Scan(
			&b.ID, &b.WorkID, &b.Notes, pq.Array(&b.Tags), &b.IsPrivate, &b.CreatedAt, &b.UpdatedAt,
			&w.Title, &w.Summary, &w.Rating, pq.Array(&w.Fandoms), pq.Array(&w.Characters),
			pq.Array(&w.Relationships), pq.Array(&w.FreeformTags), &w.WordCount, &w.ChapterCount,
			&w.IsComplete, &w.Status, &w.PublishedAt, &w.UpdatedAt,
			&hits, &kudos, &comments, &bookmarkCount)

		if err != nil {
			continue
		}

		w.ID = b.WorkID
		w.Hits = hits
		w.Kudos = kudos
		w.Comments = comments
		w.Bookmarks = bookmarkCount

		// Get work authors using database function
		var authors []models.WorkAuthor
		authorRows, err := ws.db.Query("SELECT * FROM get_work_authors($1, $2)", w.ID, viewerID)
		if err == nil {
			defer authorRows.Close()
			for authorRows.Next() {
				var author models.WorkAuthor
				if err := authorRows.Scan(&author.PseudID, &author.PseudName, &author.UserID, &author.Username, &author.IsAnonymous); err == nil {
					authors = append(authors, author)
				}
			}
		}

		bookmarks = append(bookmarks, gin.H{
			"id":         b.ID,
			"work_id":    b.WorkID,
			"notes":      b.Notes,
			"tags":       b.Tags,
			"is_private": b.IsPrivate,
			"created_at": b.CreatedAt,
			"updated_at": b.UpdatedAt,
			"work": gin.H{
				"id":            w.ID,
				"title":         w.Title,
				"summary":       w.Summary,
				"rating":        w.Rating,
				"fandoms":       w.Fandoms,
				"characters":    w.Characters,
				"relationships": w.Relationships,
				"freeform_tags": w.FreeformTags,
				"word_count":    w.WordCount,
				"chapter_count": w.ChapterCount,
				"is_complete":   w.IsComplete,
				"status":        w.Status,
				"published_at":  w.PublishedAt,
				"updated_at":    w.UpdatedAt,
				"hits":          w.Hits,
				"kudos":         w.Kudos,
				"comments":      w.Comments,
				"bookmarks":     w.Bookmarks,
				"authors":       authors,
			},
		})
	}

	c.JSON(http.StatusOK, gin.H{"bookmarks": bookmarks})
}

func (ws *WorkService) CreateBookmark(c *gin.Context) {
	workID, err := uuid.Parse(c.Param("work_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid work ID"})
		return
	}

	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	var req struct {
		Notes     string   `json:"notes"`
		Tags      []string `json:"tags"`
		IsPrivate bool     `json:"is_private"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request data"})
		return
	}

	userUUID := userID.(uuid.UUID)

	// Check if user can view this work
	var canView bool
	err = ws.db.QueryRow("SELECT can_user_view_work($1, $2)", workID, userUUID).Scan(&canView)
	if err != nil || !canView {
		c.JSON(http.StatusForbidden, gin.H{"error": "Cannot bookmark this work"})
		return
	}

	// Check if bookmark already exists
	var existingID uuid.UUID
	err = ws.db.QueryRow("SELECT id FROM bookmarks WHERE work_id = $1 AND user_id = $2", workID, userUUID).Scan(&existingID)
	if err == nil {
		c.JSON(http.StatusConflict, gin.H{"error": "You have already bookmarked this work"})
		return
	}

	// Create bookmark
	bookmarkID := uuid.New()
	now := time.Now()

	bookmark := &models.Bookmark{
		ID:        bookmarkID,
		WorkID:    workID,
		UserID:    userUUID,
		Notes:     req.Notes,
		Tags:      req.Tags,
		IsPrivate: req.IsPrivate,
		CreatedAt: now,
		UpdatedAt: now,
	}

	_, err = ws.db.Exec(`
		INSERT INTO bookmarks (id, work_id, user_id, notes, tags, is_private, created_at, updated_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
		bookmark.ID, bookmark.WorkID, bookmark.UserID, bookmark.Notes,
		pq.Array(bookmark.Tags), bookmark.IsPrivate, bookmark.CreatedAt, bookmark.UpdatedAt)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create bookmark"})
		return
	}

	// Update work bookmark count
	_, err = ws.db.Exec(`
		UPDATE works SET 
			bookmark_count = (SELECT COUNT(*) FROM bookmarks WHERE work_id = $1),
			updated_at = $2
		WHERE id = $1`, workID, now)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update bookmark count"})
		return
	}

	c.JSON(http.StatusCreated, gin.H{"bookmark": bookmark})
}

func (ws *WorkService) GetBookmarkStatus(c *gin.Context) {
	workID, err := uuid.Parse(c.Param("work_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid work ID"})
		return
	}

	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusOK, gin.H{"is_bookmarked": false})
		return
	}

	userIDStr := userID.(string)
	userUUID, err := uuid.Parse(userIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
		return
	}

	// Check if bookmark exists
	var bookmarkID uuid.UUID
	err = ws.db.QueryRow("SELECT id FROM bookmarks WHERE work_id = $1 AND user_id = $2", workID, userUUID).Scan(&bookmarkID)

	isBookmarked := err == nil
	c.JSON(http.StatusOK, gin.H{"is_bookmarked": isBookmarked})
}

func (ws *WorkService) UpdateBookmark(c *gin.Context) {
	bookmarkID, err := uuid.Parse(c.Param("bookmark_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid bookmark ID"})
		return
	}

	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	var req struct {
		Notes     *string  `json:"notes"`
		Tags      []string `json:"tags"`
		IsPrivate *bool    `json:"is_private"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request data"})
		return
	}

	userUUID := userID.(uuid.UUID)

	// Check if bookmark exists and belongs to user
	var existingBookmark models.Bookmark
	err = ws.db.QueryRow(`
		SELECT id, work_id, user_id, notes, tags, is_private, created_at, updated_at
		FROM bookmarks WHERE id = $1 AND user_id = $2`,
		bookmarkID, userUUID).Scan(
		&existingBookmark.ID, &existingBookmark.WorkID, &existingBookmark.UserID,
		&existingBookmark.Notes, pq.Array(&existingBookmark.Tags), &existingBookmark.IsPrivate,
		&existingBookmark.CreatedAt, &existingBookmark.UpdatedAt)

	if err != nil {
		if err == sql.ErrNoRows {
			c.JSON(http.StatusNotFound, gin.H{"error": "Bookmark not found"})
		} else {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch bookmark"})
		}
		return
	}

	// Update fields if provided
	if req.Notes != nil {
		existingBookmark.Notes = *req.Notes
	}
	if req.Tags != nil {
		existingBookmark.Tags = req.Tags
	}
	if req.IsPrivate != nil {
		existingBookmark.IsPrivate = *req.IsPrivate
	}
	existingBookmark.UpdatedAt = time.Now()

	// Update bookmark in database
	_, err = ws.db.Exec(`
		UPDATE bookmarks SET notes = $1, tags = $2, is_private = $3, updated_at = $4
		WHERE id = $5`,
		existingBookmark.Notes, pq.Array(existingBookmark.Tags),
		existingBookmark.IsPrivate, existingBookmark.UpdatedAt, bookmarkID)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update bookmark"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"bookmark": existingBookmark})
}

func (ws *WorkService) DeleteBookmark(c *gin.Context) {
	bookmarkID, err := uuid.Parse(c.Param("bookmark_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid bookmark ID"})
		return
	}

	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	userUUID := userID.(uuid.UUID)

	// Get bookmark to check ownership and get work_id for count update
	var workID uuid.UUID
	err = ws.db.QueryRow(`
		SELECT work_id FROM bookmarks WHERE id = $1 AND user_id = $2`,
		bookmarkID, userUUID).Scan(&workID)

	if err != nil {
		if err == sql.ErrNoRows {
			c.JSON(http.StatusNotFound, gin.H{"error": "Bookmark not found"})
		} else {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch bookmark"})
		}
		return
	}

	// Delete bookmark
	_, err = ws.db.Exec("DELETE FROM bookmarks WHERE id = $1", bookmarkID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete bookmark"})
		return
	}

	// Update work bookmark count
	_, err = ws.db.Exec(`
		UPDATE works SET 
			bookmark_count = (SELECT COUNT(*) FROM bookmarks WHERE work_id = $1),
			updated_at = $2
		WHERE id = $1`, workID, time.Now())

	if err != nil {
		// Log error but don't fail the request since bookmark was deleted
		log.Printf("Failed to update bookmark count for work %s: %v", workID, err)
	}

	c.JSON(http.StatusOK, gin.H{"message": "Bookmark deleted successfully"})
}

func (ws *WorkService) GetMyBookmarks(c *gin.Context) {
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	userUUID := userID.(uuid.UUID)

	// Parse query parameters for filtering and pagination
	page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
	limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))
	tag := c.Query("tag")
	search := c.Query("q")

	if page < 1 {
		page = 1
	}
	if limit < 1 || limit > 100 {
		limit = 20
	}
	offset := (page - 1) * limit

	// Build query with optional filters
	baseQuery := `
		SELECT b.id, b.work_id, b.notes, b.tags, b.is_private, b.created_at, b.updated_at,
			   w.title, w.summary, w.rating, w.fandoms, w.characters, w.relationships, 
			   w.freeform_tags, w.word_count, w.chapter_count, w.is_complete, w.status,
			   w.published_at, w.updated_at as work_updated_at,
			   COALESCE(ws.hits, 0) as hits, COALESCE(ws.kudos, 0) as kudos,
			   COALESCE(ws.comments, 0) as comments, COALESCE(ws.bookmarks, 0) as bookmarks
		FROM bookmarks b
		JOIN works w ON b.work_id = w.id
		LEFT JOIN work_statistics ws ON w.id = ws.work_id
		WHERE b.user_id = $1`

	args := []interface{}{userUUID}
	argCount := 1

	// Add tag filter
	if tag != "" {
		argCount++
		baseQuery += fmt.Sprintf(" AND $%d = ANY(b.tags)", argCount)
		args = append(args, tag)
	}

	// Add search filter
	if search != "" {
		argCount++
		baseQuery += fmt.Sprintf(" AND (w.title ILIKE $%d OR w.summary ILIKE $%d OR b.notes ILIKE $%d)", argCount, argCount, argCount)
		args = append(args, "%"+search+"%")
	}

	// Count total bookmarks for pagination
	countQuery := strings.Replace(baseQuery,
		"SELECT b.id, b.work_id, b.notes, b.tags, b.is_private, b.created_at, b.updated_at, w.title, w.summary, w.rating, w.fandoms, w.characters, w.relationships, w.freeform_tags, w.word_count, w.chapter_count, w.is_complete, w.status, w.published_at, w.updated_at as work_updated_at, COALESCE(ws.hits, 0) as hits, COALESCE(ws.kudos, 0) as kudos, COALESCE(ws.comments, 0) as comments, COALESCE(ws.bookmarks, 0) as bookmarks",
		"SELECT COUNT(*)", 1)

	var total int
	err := ws.db.QueryRow(countQuery, args...).Scan(&total)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to count bookmarks"})
		return
	}

	// Add ordering and pagination
	baseQuery += " ORDER BY b.created_at DESC"
	argCount++
	baseQuery += fmt.Sprintf(" LIMIT $%d", argCount)
	args = append(args, limit)
	argCount++
	baseQuery += fmt.Sprintf(" OFFSET $%d", argCount)
	args = append(args, offset)

	rows, err := ws.db.Query(baseQuery, args...)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch bookmarks"})
		return
	}
	defer rows.Close()

	var bookmarks []gin.H
	for rows.Next() {
		var b models.Bookmark
		var w models.Work
		var hits, kudos, comments, bookmarkCount int

		err := rows.Scan(
			&b.ID, &b.WorkID, &b.Notes, pq.Array(&b.Tags), &b.IsPrivate, &b.CreatedAt, &b.UpdatedAt,
			&w.Title, &w.Summary, &w.Rating, pq.Array(&w.Fandoms), pq.Array(&w.Characters),
			pq.Array(&w.Relationships), pq.Array(&w.FreeformTags), &w.WordCount, &w.ChapterCount,
			&w.IsComplete, &w.Status, &w.PublishedAt, &w.UpdatedAt,
			&hits, &kudos, &comments, &bookmarkCount)

		if err != nil {
			continue
		}

		w.ID = b.WorkID
		w.Hits = hits
		w.Kudos = kudos
		w.Comments = comments
		w.Bookmarks = bookmarkCount

		// Get work authors
		var authors []models.WorkAuthor
		authorRows, err := ws.db.Query("SELECT * FROM get_work_authors($1, $2)", w.ID, userUUID)
		if err == nil {
			defer authorRows.Close()
			for authorRows.Next() {
				var author models.WorkAuthor
				if err := authorRows.Scan(&author.PseudID, &author.PseudName, &author.UserID, &author.Username, &author.IsAnonymous); err == nil {
					authors = append(authors, author)
				}
			}
		}

		bookmarks = append(bookmarks, gin.H{
			"id":         b.ID,
			"work_id":    b.WorkID,
			"notes":      b.Notes,
			"tags":       b.Tags,
			"is_private": b.IsPrivate,
			"created_at": b.CreatedAt,
			"updated_at": b.UpdatedAt,
			"work": gin.H{
				"id":            w.ID,
				"title":         w.Title,
				"summary":       w.Summary,
				"rating":        w.Rating,
				"fandoms":       w.Fandoms,
				"characters":    w.Characters,
				"relationships": w.Relationships,
				"freeform_tags": w.FreeformTags,
				"word_count":    w.WordCount,
				"chapter_count": w.ChapterCount,
				"is_complete":   w.IsComplete,
				"status":        w.Status,
				"published_at":  w.PublishedAt,
				"updated_at":    w.UpdatedAt,
				"hits":          w.Hits,
				"kudos":         w.Kudos,
				"comments":      w.Comments,
				"bookmarks":     w.Bookmarks,
				"authors":       authors,
			},
		})
	}

	totalPages := (total + limit - 1) / limit

	c.JSON(http.StatusOK, gin.H{
		"bookmarks": bookmarks,
		"pagination": gin.H{
			"page":        page,
			"limit":       limit,
			"total":       total,
			"total_pages": totalPages,
		},
	})
}

func (ws *WorkService) GetMyWorks(c *gin.Context) {
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	// Build query with pagination
	page := 1
	if pageStr := c.Query("page"); pageStr != "" {
		if p, err := strconv.Atoi(pageStr); err == nil && p > 0 {
			page = p
		}
	}

	limit := 20
	if limitStr := c.Query("limit"); limitStr != "" {
		if l, err := strconv.Atoi(limitStr); err == nil && l > 0 && l <= 100 {
			limit = l
		}
	}

	offset := (page - 1) * limit

	// Query to get user's works through creatorships
	query := `
		SELECT DISTINCT w.id, w.title, w.summary, w.language, w.rating, 
			w.category, w.warnings, w.fandoms, w.characters, w.relationships, w.freeform_tags,
			w.word_count, w.chapter_count, w.max_chapters, w.is_complete, w.status,
			w.published_at, w.updated_at, w.hit_count, w.kudos_count, w.comment_count, w.bookmark_count
		FROM works w
		JOIN creatorships c ON w.id = c.creation_id
		JOIN pseuds p ON c.pseud_id = p.id
		WHERE c.creation_type = 'Work' 
		AND c.approved = true
		AND p.user_id = $1
		ORDER BY w.updated_at DESC
		LIMIT $2 OFFSET $3`

	rows, err := ws.db.Query(query, userID, limit, offset)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch your works"})
		return
	}
	defer rows.Close()

	var works []map[string]interface{}
	for rows.Next() {
		var work map[string]interface{} = make(map[string]interface{})
		var id, title, language, rating, status string
		var summary sql.NullString
		var category, warnings sql.NullString
		var fandoms, characters, relationships, freeformTags pq.StringArray
		var wordCount, chapterCount int
		var maxChapters sql.NullInt64
		var isComplete bool
		var publishedAt sql.NullTime
		var updatedAt time.Time
		var hits, kudos, comments, bookmarks int

		err := rows.Scan(
			&id, &title, &summary, &language, &rating,
			&category, &warnings, &fandoms, &characters, &relationships, &freeformTags,
			&wordCount, &chapterCount, &maxChapters, &isComplete, &status,
			&publishedAt, &updatedAt, &hits, &kudos, &comments, &bookmarks)
		if err != nil {
			continue
		}

		work["id"] = id
		work["title"] = title
		work["summary"] = summary.String
		work["language"] = language
		work["rating"] = rating
		work["fandoms"] = []string(fandoms)
		work["characters"] = []string(characters)
		work["relationships"] = []string(relationships)
		work["freeform_tags"] = []string(freeformTags)
		work["word_count"] = wordCount
		work["chapter_count"] = chapterCount
		if maxChapters.Valid {
			work["max_chapters"] = maxChapters.Int64
		}
		work["is_complete"] = isComplete
		work["status"] = status
		if publishedAt.Valid {
			work["published_at"] = publishedAt.Time
		} else {
			work["published_at"] = nil
		}
		work["updated_at"] = updatedAt
		work["hits"] = hits
		work["kudos"] = kudos
		work["comments"] = comments
		work["bookmarks"] = bookmarks

		works = append(works, work)
	}

	c.JSON(http.StatusOK, gin.H{"works": works})
}

func (ws *WorkService) GetMySeries(c *gin.Context) {
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	// Build query with pagination
	page := 1
	if pageStr := c.Query("page"); pageStr != "" {
		if p, err := strconv.Atoi(pageStr); err == nil && p > 0 {
			page = p
		}
	}

	limit := 20
	if limitStr := c.Query("limit"); limitStr != "" {
		if l, err := strconv.Atoi(limitStr); err == nil && l > 0 && l <= 100 {
			limit = l
		}
	}

	offset := (page - 1) * limit

	query := `
		SELECT s.id, s.title, s.description, s.notes, s.user_id, s.is_complete,
			s.work_count, s.created_at, s.updated_at, u.username
		FROM series s
		JOIN users u ON s.user_id = u.id
		WHERE s.user_id = $1
		ORDER BY s.updated_at DESC
		LIMIT $2 OFFSET $3`

	rows, err := ws.db.Query(query, userID, limit, offset)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch your series"})
		return
	}
	defer rows.Close()

	var series []models.Series
	for rows.Next() {
		var s models.Series
		err := rows.Scan(
			&s.ID, &s.Title, &s.Summary, &s.Notes, &s.UserID, &s.IsComplete,
			&s.WorkCount, &s.CreatedAt, &s.UpdatedAt, &s.Username)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to scan series"})
			return
		}

		// Calculate word count for each series
		ws.db.QueryRow(`
			SELECT COALESCE(SUM(w.word_count), 0) 
			FROM works w 
			JOIN series_works sw ON w.id = sw.work_id
			WHERE sw.series_id = $1`, s.ID).Scan(&s.WordCount)

		series = append(series, s)
	}

	// Get total count for pagination
	var total int
	err = ws.db.QueryRow("SELECT COUNT(*) FROM series WHERE user_id = $1", userID).Scan(&total)
	if err != nil {
		total = len(series) // Fallback
	}

	c.JSON(http.StatusOK, gin.H{
		"series": series,
		"pagination": gin.H{
			"page":        page,
			"limit":       limit,
			"total":       total,
			"total_pages": (total + limit - 1) / limit,
		},
	})
}

func (ws *WorkService) GetMyCollections(c *gin.Context) {
	// TODO: Implement personal collections listing
	c.JSON(http.StatusOK, gin.H{"collections": []gin.H{}})
}

func (ws *WorkService) GetMyComments(c *gin.Context) {
	// TODO: Implement personal comments listing
	c.JSON(http.StatusOK, gin.H{"comments": []gin.H{}})
}

func (ws *WorkService) GetMyStats(c *gin.Context) {
	// TODO: Implement personal statistics
	c.JSON(http.StatusOK, gin.H{"stats": gin.H{}})
}

// Privacy and moderation handlers

func (ws *WorkService) ModerateComment(c *gin.Context) {
	commentID, err := uuid.Parse(c.Param("comment_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid comment ID"})
		return
	}

	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	var req struct {
		Status string `json:"status" validate:"required,oneof=published hidden deleted spam"`
		Reason string `json:"reason"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request data", "details": err.Error()})
		return
	}

	// Check if user is the author of the work this comment belongs to
	var authorID uuid.UUID
	err = ws.db.QueryRow(`
		SELECT w.user_id 
		FROM works w
		JOIN comments c ON w.id = c.work_id
		WHERE c.id = $1`, commentID).Scan(&authorID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Comment not found"})
		return
	}

	if authorID != userID.(uuid.UUID) {
		c.JSON(http.StatusForbidden, gin.H{"error": "Only work authors can moderate comments"})
		return
	}

	// Update comment status
	now := time.Now()
	_, err = ws.db.Exec(`
		UPDATE comments 
		SET status = $1, moderation_reason = $2, moderated_by = $3, moderated_at = $4, updated_at = $5
		WHERE id = $6`,
		req.Status, req.Reason, userID, now, now, commentID)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to moderate comment"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Comment moderation updated"})
}

func (ws *WorkService) BlockUser(c *gin.Context) {
	blockedUserID, err := uuid.Parse(c.Param("user_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
		return
	}

	blockerID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	var req struct {
		BlockType string `json:"block_type" validate:"required,oneof=full comments works"`
		Reason    string `json:"reason"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request data", "details": err.Error()})
		return
	}

	// Can't block yourself
	if blockerID.(uuid.UUID) == blockedUserID {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Cannot block yourself"})
		return
	}

	// Create or update block
	blockID := uuid.New()
	now := time.Now()

	_, err = ws.db.Exec(`
		INSERT INTO user_blocks (id, blocker_id, blocked_id, block_type, reason, created_at)
		VALUES ($1, $2, $3, $4, $5, $6)
		ON CONFLICT (blocker_id, blocked_id)
		DO UPDATE SET block_type = EXCLUDED.block_type, reason = EXCLUDED.reason`,
		blockID, blockerID, blockedUserID, req.BlockType, req.Reason, now)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to block user"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "User blocked successfully"})
}

func (ws *WorkService) UnblockUser(c *gin.Context) {
	blockedUserID, err := uuid.Parse(c.Param("user_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
		return
	}

	blockerID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	_, err = ws.db.Exec(`
		DELETE FROM user_blocks 
		WHERE blocker_id = $1 AND blocked_id = $2`,
		blockerID, blockedUserID)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to unblock user"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "User unblocked successfully"})
}

func (ws *WorkService) ReportComment(c *gin.Context) {
	commentID, err := uuid.Parse(c.Param("comment_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid comment ID"})
		return
	}

	var req struct {
		Reason      string `json:"reason" validate:"required,oneof=spam harassment off_topic inappropriate hate_speech doxxing other"`
		Description string `json:"description"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request data", "details": err.Error()})
		return
	}

	// Get reporter info
	reporterID, hasUser := c.Get("user_id")
	var reporterUUID *uuid.UUID
	if hasUser {
		reporterVal := reporterID.(uuid.UUID)
		reporterUUID = &reporterVal
	}

	clientIP := c.ClientIP()

	// Create report
	reportID := uuid.New()
	now := time.Now()

	_, err = ws.db.Exec(`
		INSERT INTO comment_reports (id, comment_id, reporter_id, reporter_ip, reason, description, created_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7)`,
		reportID, commentID, reporterUUID, clientIP, req.Reason, req.Description, now)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to submit report"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Report submitted successfully"})
}

func (ws *WorkService) ReportWork(c *gin.Context) {
	workID, err := uuid.Parse(c.Param("work_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid work ID"})
		return
	}

	var req struct {
		Reason      string `json:"reason" validate:"required,oneof=copyright plagiarism harassment inappropriate_content wrong_rating missing_warnings spam other"`
		Description string `json:"description"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request data", "details": err.Error()})
		return
	}

	// Get reporter info
	reporterID, hasUser := c.Get("user_id")
	var reporterUUID *uuid.UUID
	if hasUser {
		reporterVal := reporterID.(uuid.UUID)
		reporterUUID = &reporterVal
	}

	clientIP := c.ClientIP()

	// Create report
	reportID := uuid.New()
	now := time.Now()

	_, err = ws.db.Exec(`
		INSERT INTO work_reports (id, work_id, reporter_id, reporter_ip, reason, description, created_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7)`,
		reportID, workID, reporterUUID, clientIP, req.Reason, req.Description, now)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to submit report"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Report submitted successfully"})
}

// User muting handlers (matching AO3's implementation)

func (ws *WorkService) MuteUser(c *gin.Context) {
	mutedUserID, err := uuid.Parse(c.Param("user_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
		return
	}

	muterID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	var req struct {
		Reason string `json:"reason"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request data", "details": err.Error()})
		return
	}

	// Can't mute yourself
	if muterID.(uuid.UUID) == mutedUserID {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Cannot mute yourself"})
		return
	}

	// Check mute limit (similar to AO3's limits)
	var muteCount int
	err = ws.db.QueryRow("SELECT count_user_mutes($1)", muterID).Scan(&muteCount)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check mute limit"})
		return
	}

	maxMutes := 100 // Similar to AO3's limits
	if muteCount >= maxMutes {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Maximum muted users limit reached"})
		return
	}

	// Create or update mute
	muteID := uuid.New()
	now := time.Now()

	_, err = ws.db.Exec(`
		INSERT INTO user_mutes (id, muter_id, muted_id, reason, created_at, updated_at)
		VALUES ($1, $2, $3, $4, $5, $6)
		ON CONFLICT (muter_id, muted_id)
		DO UPDATE SET reason = EXCLUDED.reason, updated_at = EXCLUDED.updated_at`,
		muteID, muterID, mutedUserID, req.Reason, now, now)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to mute user"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "User muted successfully"})
}

func (ws *WorkService) UnmuteUser(c *gin.Context) {
	mutedUserID, err := uuid.Parse(c.Param("user_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
		return
	}

	muterID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	_, err = ws.db.Exec(`
		DELETE FROM user_mutes 
		WHERE muter_id = $1 AND muted_id = $2`,
		muterID, mutedUserID)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to unmute user"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "User unmuted successfully"})
}

func (ws *WorkService) GetMutedUsers(c *gin.Context) {
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	// Get user's muted list using the helper function
	rows, err := ws.db.Query("SELECT * FROM get_user_muted_list($1)", userID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch muted users"})
		return
	}
	defer rows.Close()

	type MutedUser struct {
		UserID   uuid.UUID `json:"user_id"`
		Username string    `json:"username"`
		Reason   string    `json:"reason"`
		MutedAt  time.Time `json:"muted_at"`
	}

	mutedUsers := []MutedUser{}
	for rows.Next() {
		var mutedUser MutedUser
		err := rows.Scan(&mutedUser.UserID, &mutedUser.Username, &mutedUser.Reason, &mutedUser.MutedAt)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to scan muted user"})
			return
		}
		mutedUsers = append(mutedUsers, mutedUser)
	}

	c.JSON(http.StatusOK, gin.H{"muted_users": mutedUsers})
}

func (ws *WorkService) GetMuteStatus(c *gin.Context) {
	targetUserID, err := uuid.Parse(c.Param("user_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
		return
	}

	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	// Check if user has muted the target user
	var isMuted bool
	err = ws.db.QueryRow("SELECT is_user_muted($1, $2)", userID, targetUserID).Scan(&isMuted)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check mute status"})
		return
	}

	var muteInfo struct {
		IsMuted bool      `json:"is_muted"`
		Reason  string    `json:"reason,omitempty"`
		MutedAt time.Time `json:"muted_at,omitempty"`
	}

	muteInfo.IsMuted = isMuted

	// If muted, get additional details
	if isMuted {
		err = ws.db.QueryRow(`
			SELECT reason, created_at 
			FROM user_mutes 
			WHERE muter_id = $1 AND muted_id = $2`,
			userID, targetUserID).Scan(&muteInfo.Reason, &muteInfo.MutedAt)
		if err != nil {
			// Still return the mute status even if we can't get details
			c.JSON(http.StatusOK, gin.H{"is_muted": true})
			return
		}
	}

	c.JSON(http.StatusOK, muteInfo)
}

// AO3 Core Features Handlers

// Pseud management
func (ws *WorkService) CreatePseud(c *gin.Context) {
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	var req struct {
		Name        string `json:"name" validate:"required,min=1,max=40"`
		Description string `json:"description"`
		IsDefault   bool   `json:"is_default"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request data", "details": err.Error()})
		return
	}

	// Create pseud using database function
	var pseudID uuid.UUID
	err := ws.db.QueryRow("SELECT create_pseud($1, $2, $3)", userID, req.Name, req.IsDefault).Scan(&pseudID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create pseud", "details": err.Error()})
		return
	}

	// Get the created pseud
	var pseud models.Pseud
	err = ws.db.QueryRow(`
		SELECT id, user_id, name, description, is_default, created_at, updated_at
		FROM pseuds WHERE id = $1`, pseudID).Scan(
		&pseud.ID, &pseud.UserID, &pseud.Name, &pseud.Description,
		&pseud.IsDefault, &pseud.CreatedAt, &pseud.UpdatedAt)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch created pseud"})
		return
	}

	c.JSON(http.StatusCreated, gin.H{"pseud": pseud})
}

func (ws *WorkService) GetUserPseuds(c *gin.Context) {
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	rows, err := ws.db.Query(`
		SELECT id, user_id, name, description, is_default, created_at, updated_at
		FROM pseuds WHERE user_id = $1 ORDER BY is_default DESC, name`, userID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch pseuds"})
		return
	}
	defer rows.Close()

	var pseuds []models.Pseud
	for rows.Next() {
		var pseud models.Pseud
		err := rows.Scan(&pseud.ID, &pseud.UserID, &pseud.Name, &pseud.Description,
			&pseud.IsDefault, &pseud.CreatedAt, &pseud.UpdatedAt)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to scan pseud"})
			return
		}
		pseuds = append(pseuds, pseud)
	}

	c.JSON(http.StatusOK, gin.H{"pseuds": pseuds})
}

// Work gifting
func (ws *WorkService) GiftWork(c *gin.Context) {
	workID, err := uuid.Parse(c.Param("work_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid work ID"})
		return
	}

	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	var req struct {
		PseudID       *uuid.UUID `json:"pseud_id"`
		RecipientName string     `json:"recipient_name"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request data"})
		return
	}

	// Validate that user is an author of the work
	var isAuthor bool
	err = ws.db.QueryRow(`
		SELECT EXISTS(
			SELECT 1 FROM creatorships c
			JOIN pseuds p ON c.pseud_id = p.id
			WHERE c.creation_id = $1 AND c.creation_type = 'Work' 
			AND c.approved = true AND p.user_id = $2
		)`, workID, userID).Scan(&isAuthor)

	if err != nil || !isAuthor {
		c.JSON(http.StatusForbidden, gin.H{"error": "You can only gift works you authored"})
		return
	}

	// Create gift
	giftID := uuid.New()
	now := time.Now()

	gift := &models.Gift{
		ID:            giftID,
		WorkID:        workID,
		PseudID:       req.PseudID,
		RecipientName: req.RecipientName,
		Rejected:      false,
		CreatedAt:     now,
		UpdatedAt:     now,
	}

	_, err = ws.db.Exec(`
		INSERT INTO gifts (id, work_id, pseud_id, recipient_name, rejected, created_at, updated_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7)`,
		gift.ID, gift.WorkID, gift.PseudID, gift.RecipientName,
		gift.Rejected, gift.CreatedAt, gift.UpdatedAt)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create gift"})
		return
	}

	c.JSON(http.StatusCreated, gin.H{"gift": gift})
}

func (ws *WorkService) GetWorkGifts(c *gin.Context) {
	workID, err := uuid.Parse(c.Param("work_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid work ID"})
		return
	}

	rows, err := ws.db.Query(`
		SELECT g.id, g.work_id, g.pseud_id, g.recipient_name, g.rejected, 
			g.created_at, g.updated_at, p.name as pseud_name, u.username
		FROM gifts g
		LEFT JOIN pseuds p ON g.pseud_id = p.id
		LEFT JOIN users u ON p.user_id = u.id
		WHERE g.work_id = $1 AND g.rejected = false
		ORDER BY g.created_at`, workID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch gifts"})
		return
	}
	defer rows.Close()

	var gifts []interface{}
	for rows.Next() {
		var gift models.Gift
		var pseudName, username sql.NullString
		err := rows.Scan(&gift.ID, &gift.WorkID, &gift.PseudID, &gift.RecipientName,
			&gift.Rejected, &gift.CreatedAt, &gift.UpdatedAt, &pseudName, &username)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to scan gift"})
			return
		}

		giftData := gin.H{
			"id":         gift.ID,
			"work_id":    gift.WorkID,
			"rejected":   gift.Rejected,
			"created_at": gift.CreatedAt,
		}

		if gift.PseudID != nil {
			giftData["recipient"] = gin.H{
				"pseud_id":   gift.PseudID,
				"pseud_name": pseudName.String,
				"username":   username.String,
			}
		} else {
			giftData["recipient_name"] = gift.RecipientName
		}

		gifts = append(gifts, giftData)
	}

	c.JSON(http.StatusOK, gin.H{"gifts": gifts})
}

// Work orphaning
func (ws *WorkService) OrphanWork(c *gin.Context) {
	workID, err := uuid.Parse(c.Param("work_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid work ID"})
		return
	}

	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	// Use database function to orphan the work
	var success bool
	err = ws.db.QueryRow("SELECT orphan_work($1, $2)", workID, userID).Scan(&success)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to orphan work"})
		return
	}

	if !success {
		c.JSON(http.StatusForbidden, gin.H{"error": "You are not an author of this work"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Work orphaned successfully"})
}

// Get work authors (respecting anonymity)
func (ws *WorkService) GetWorkAuthors(c *gin.Context) {
	workID, err := uuid.Parse(c.Param("work_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid work ID"})
		return
	}

	userID, _ := c.Get("user_id")

	// Use database function to get authors respecting anonymity
	rows, err := ws.db.Query("SELECT * FROM get_work_authors($1, $2)", workID, userID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch authors"})
		return
	}
	defer rows.Close()

	var authors []models.WorkAuthor
	for rows.Next() {
		var author models.WorkAuthor
		err := rows.Scan(&author.PseudID, &author.PseudName, &author.UserID, &author.Username, &author.IsAnonymous)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to scan author"})
			return
		}
		authors = append(authors, author)
	}

	c.JSON(http.StatusOK, gin.H{"authors": authors})
}

// Add co-author to work
func (ws *WorkService) AddCoAuthor(c *gin.Context) {
	workID, err := uuid.Parse(c.Param("work_id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid work ID"})
		return
	}

	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	var req struct {
		PseudID uuid.UUID `json:"pseud_id" validate:"required"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request data"})
		return
	}

	// Verify user is current author
	var isAuthor bool
	err = ws.db.QueryRow(`
		SELECT EXISTS(
			SELECT 1 FROM creatorships c
			JOIN pseuds p ON c.pseud_id = p.id
			WHERE c.creation_id = $1 AND c.creation_type = 'Work' 
			AND c.approved = true AND p.user_id = $2
		)`, workID, userID).Scan(&isAuthor)

	if err != nil || !isAuthor {
		c.JSON(http.StatusForbidden, gin.H{"error": "Only existing authors can add co-authors"})
		return
	}

	// Add new creatorship
	creatorshipID := uuid.New()
	now := time.Now()

	_, err = ws.db.Exec(`
		INSERT INTO creatorships (id, creation_id, creation_type, pseud_id, approved, created_at, updated_at)
		VALUES ($1, $2, 'Work', $3, false, $4, $5)
		ON CONFLICT (creation_id, creation_type, pseud_id) DO NOTHING`,
		creatorshipID, workID, req.PseudID, now, now)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to add co-author"})
		return
	}

	c.JSON(http.StatusCreated, gin.H{"message": "Co-author invitation sent"})
}

func (ws *WorkService) AdminListWorks(c *gin.Context) {
	// TODO: Implement admin work listing
	c.JSON(http.StatusOK, gin.H{"works": []gin.H{}})
}

func (ws *WorkService) AdminUpdateWorkStatus(c *gin.Context) {
	// TODO: Implement admin work status updates
	c.JSON(http.StatusOK, gin.H{"message": "Work status updated"})
}

func (ws *WorkService) AdminDeleteWork(c *gin.Context) {
	// TODO: Implement admin work deletion
	c.JSON(http.StatusOK, gin.H{"message": "Work deleted"})
}

func (ws *WorkService) AdminListComments(c *gin.Context) {
	// TODO: Implement admin comment listing
	c.JSON(http.StatusOK, gin.H{"comments": []gin.H{}})
}

func (ws *WorkService) AdminUpdateCommentStatus(c *gin.Context) {
	// TODO: Implement admin comment status updates
	c.JSON(http.StatusOK, gin.H{"message": "Comment status updated"})
}

func (ws *WorkService) AdminDeleteComment(c *gin.Context) {
	// TODO: Implement admin comment deletion
	c.JSON(http.StatusOK, gin.H{"message": "Comment deleted"})
}

func (ws *WorkService) AdminGetReports(c *gin.Context) {
	// TODO: Implement admin reports listing
	c.JSON(http.StatusOK, gin.H{"reports": []gin.H{}})
}

func (ws *WorkService) AdminGetStatistics(c *gin.Context) {
	// TODO: Implement admin statistics
	c.JSON(http.StatusOK, gin.H{"stats": gin.H{}})
}
